<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiajiaba.github.io</id>
    <title>JIAJIA</title>
    <updated>2019-09-02T13:40:01.649Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiajiaba.github.io"/>
    <link rel="self" href="https://jiajiaba.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiajiaba.github.io/images/avatar.png</logo>
    <icon>https://jiajiaba.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, JIAJIA</rights>
    <entry>
        <title type="html"><![CDATA[Go语言基础之切片]]></title>
        <id>https://jiajiaba.github.io/post/Slice</id>
        <link href="https://jiajiaba.github.io/post/Slice">
        </link>
        <updated>2019-09-02T12:58:14.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
<!-- more -->
<h2 id="colorred切片slice"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mo>(</mo><mi>S</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片(Slice)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mopen" style="color:red;">(</span><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">e</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。<br>
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>
<h2 id="colorred切片的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h2>
<p><code>var 变量名 []切片类型</code></p>
<pre><code class="language-/usr/bin/env">func main() {
	var a []int
	var b = []int{}
	fmt.Println(a == nil)
	fmt.Println(b == nil)

	var c = []bool{false, true}
	var d = []bool{false, true}
	fmt.Println(c == d)
}
</code></pre>
<h2 id="colorred切片的长度和容量"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的长度和容量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">量</span></span></span></span></span></h2>
<ol>
<li>切片拥有自己的长度和容量</li>
<li>可以通过使用内置的len()函数求长度</li>
<li>使用内置的cap()函数求切片的容量。</li>
</ol>
<h2 id="colorred基于数组定义的切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">基</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{基于数组定义的切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">基</span><span class="mord cjk_fallback" style="color:red;">于</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<p>其使用方法类似python的切片</p>
<pre><code class="language-/usr/bin/env"> func main() {
	// 基于数组定义切片
	a := [5]int{55, 56, 57, 58, 59}
	b := a[1:4]                     //基于数组a创建切片，包括元素a[1],a[2],a[3]
	fmt.Println(b)                  //[56 57 58]
	fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:[]int
}
</code></pre>
<h2 id="colorred切片再切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片再切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">再</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	//切片再切片
	a := [...]string{&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;n3&quot;, &quot;n4&quot;, &quot;n5&quot;}
	fmt.Printf(&quot;a:%v type:%T len:%d  cap:%d\n&quot;, a, a, len(a), cap(a))
	b := a[1:3]
	fmt.Printf(&quot;b:%v type:%T len:%d  cap:%d\n&quot;, b, b, len(b), cap(b))
	c := b[1:5]
	fmt.Printf(&quot;c:%v type:%T len:%d  cap:%d\n&quot;, c, c, len(c), cap(c))
}
</code></pre>
<p>输出：</p>
<pre><code class="language-/usr/bin/env">a:[n0 n1 n2 n3 n4 n5] type:[6]string len:6  cap:6
b:[n1 n2] type:[]string len:2  cap:5
c:[n2 n3 n4 n5] type:[]string len:4  cap:4
</code></pre>
<h3 id="注意-对切片进行再切片时索引不能超过原数组的长度否则会出现索引越界的错误">注意： 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</h3>
<h2 id="colorredmake函数构造切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">造</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{make函数构造切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03148em;color:red;">k</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">造</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>
<h2 id="colorred切片的本质"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">质</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的本质}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">本</span><span class="mord cjk_fallback" style="color:red;">质</span></span></span></span></span></h2>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<p>举个例子，有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。<br>
<img src="https://jiajiaba.github.io/post-images/1567430493603.png" alt=""><br>
切片s2 := a[3:6]，相应示意图如下：<br>
<img src="https://jiajiaba.github.io/post-images/1567430512393.png" alt=""></p>
<h2 id="colorred切片不能直接比较"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片不能直接比较}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">直</span><span class="mord cjk_fallback" style="color:red;">接</span><span class="mord cjk_fallback" style="color:red;">比</span><span class="mord cjk_fallback" style="color:red;">较</span></span></span></span></span></h2>
<ol>
<li>切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。</li>
<li>切片唯一合法的比较操作是和nil比较。</li>
<li>重要：判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断</li>
</ol>
<pre><code class="language-/usr/bin/env">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>
<h2 id="colorred切片拷贝赋值"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">拷</mi><mi mathvariant="normal">贝</mi><mi mathvariant="normal">赋</mi><mi mathvariant="normal">值</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片拷贝赋值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">拷</span><span class="mord cjk_fallback" style="color:red;">贝</span><span class="mord cjk_fallback" style="color:red;">赋</span><span class="mord cjk_fallback" style="color:red;">值</span></span></span></span></span></h2>
<p>注意：切片是引用类型，切片拷贝前后，两个变量共享底层数组</p>
<pre><code class="language-/usr/bin/env">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>
<p>copy方法：</p>
<pre><code class="language-/usr/bin/env">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>
<h2 id="colorred切片append方法扩容特点"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">扩</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">点</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片append方法扩容特点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">d</span><span class="mord cjk_fallback" style="color:red;">方</span><span class="mord cjk_fallback" style="color:red;">法</span><span class="mord cjk_fallback" style="color:red;">扩</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">特</span><span class="mord cjk_fallback" style="color:red;">点</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var a = make([]int, 0, 1)
	oldCaps := cap(a)
	for i := 0; i &lt; 30; i++ {
		a = append(a, i)
		if newCaps := cap(a); oldCaps &lt; newCaps {
			fmt.Printf(&quot;cap:%d======&gt;%d\n&quot;, oldCaps, newCaps)
			oldCaps = newCaps
		}
	}
}
</code></pre>
<p>输出：</p>
<pre><code>cap:1======&gt;2
cap:2======&gt;4
cap:4======&gt;8
cap:8======&gt;16
cap:16======&gt;32
</code></pre>
<h2 id="colorred切片删除元素"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片删除元素}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">删</span><span class="mord cjk_fallback" style="color:red;">除</span><span class="mord cjk_fallback" style="color:red;">元</span><span class="mord cjk_fallback" style="color:red;">素</span></span></span></span></span></h2>
<p>Go语言中并没有删除切片元素的专用方法，可以使用切片本身的特性来删除元素</p>
<pre><code class="language-/usr/bin/env">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之数组]]></title>
        <id>https://jiajiaba.github.io/post/shuzu</id>
        <link href="https://jiajiaba.github.io/post/shuzu">
        </link>
        <updated>2019-09-02T07:03:10.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言数组的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言数组的基本使用</p>
<!-- more -->
<h2 id="colorredarray数组定义"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></strong></h2>
<p>数组是同一种数据类型元素的集合。<br>
数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>
数组基本语法：<br>
<code>var 数组变量名 [元素数量]类型</code></p>
<pre><code class="language-/usr/bin/env">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mo>:</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">。</mi><mo>[</mo><mn>5</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">和</mi><mo>[</mo><mn>10</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{注意:数组的长度必须是常量，一旦定义，长度不能改变。[5]int和[10]int是不同类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">注</span><span class="mord cjk_fallback" style="color:red;">意</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">一</span><span class="mord cjk_fallback" style="color:red;">旦</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">改</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">。</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">5</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">1</span><span class="mord" style="color:red;">0</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></p>
<h2 id="colorredarray数组初始化"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">初</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">化</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)初始化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">初</span><span class="mord cjk_fallback" style="color:red;">始</span><span class="mord cjk_fallback" style="color:red;">化</span></span></span></span></span></h2>
<ul>
<li>初始化数组时可以使用初始化列表来设置数组元素的值。</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>短声明</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	x := [3]int{1, 2, 3}
	fmt.Println(x)
}
</code></pre>
<ul>
<li>让编译器根据初始值的个数自行推断数组的长度</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                          //数组会初始化为int类型的零值
	var numArray = [...]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                        //[0 0 0]
	fmt.Println(numArray)                         //[1 2 0]
	fmt.Println(cityArray)                        //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>使用指定索引值的方式来初始化数组</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{1: &quot;北京&quot;, 3: &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	fmt.Println(cityArray)                              //[ 北京  上海 深圳]
	fmt.Printf(&quot;type is %T&quot;, cityArray)                 //type is [5]string
}
</code></pre>
<h2 id="colorredarray数组遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	//for遍历
	for i := 0; i &lt; len(cityArray); i++ {
		fmt.Println(cityArray[i])
	}
	//for range遍历
	for i, data := range cityArray {
		fmt.Println(i, data)
	}
}
</code></pre>
<h2 id="colorred多维数组"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">多</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{多维数组}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">多</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span></span></span></span></span></h2>
<p>以二维数组为例</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[1][1]) //支持索引取值:深圳
}
</code></pre>
<h2 id="colorred二维数组的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{二维数组的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">二</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>
<p>输出：</p>
<pre><code>北京	上海	
广州	深圳	
成都	重庆
</code></pre>
<p>注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：</p>
<pre><code class="language-/usr/bin/env">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>
<h2 id="colorred数组是值类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{数组是值类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var x = [3]int{1, 2, 3}
	fmt.Println(x)
	f1(x)
	fmt.Println(x)
}

func f1(a [3]int) {
	a[0] = 100      //改变第一个值
}
</code></pre>
<p>输出：</p>
<pre><code>[1 2 3]
[1 2 3]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之流程控制]]></title>
        <id>https://jiajiaba.github.io/post/liuchengkongzhi</id>
        <link href="https://jiajiaba.github.io/post/liuchengkongzhi">
        </link>
        <updated>2019-09-02T03:07:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
 <!-- more -->
<h3 id="colorredifelse分支结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>(</mo><mi mathvariant="normal">分</mi><mi mathvariant="normal">支</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{if..else..(分支结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">支</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>if基本使用格式：</p>
<pre><code class="language-Go">if 表达式1 {
    分支1
} else if 表达式2 {
    分支2
} else{
    分支3
}
</code></pre>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	a:=10
	if a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>注意：Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，否则编译错误。</p>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	if a := 10; a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>另外，if语句还支持初始化语句，初始化条件和判断条件以分号分隔。但是需要注意的是，例子中a这个变量只在if语句块里面生效。</p>
<h3 id="colorredfor循环结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi mathvariant="normal">循</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{for(循环结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">循</span><span class="mord cjk_fallback" style="color:red;">环</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>for基本使用格式</p>
<pre><code>for 初始语句;条件表达式;结束语句{
			循环体语句
}
</code></pre>
<pre><code class="language-/usr/bin/env">func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<h3 id="其他特殊写法">其他特殊写法</h3>
<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for ; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<p>for循环的初始语句和结束语句都可以省略，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for i &lt; 10 {
		fmt.Println(i)
	}
}
</code></pre>
<p>无限循环，例如：</p>
<pre><code class="language-/usr/bin/env">for {
	循环语句体
}
</code></pre>
<p>for range (键值循环)使用，例如:</p>
<pre><code class="language-/usr/bin/env">func main() {
	str := &quot;abc&quot;
	for i, data := range str {
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, data)
	}

	for i := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}

	for i, _ := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}
}
</code></pre>
<h3 id="colorredswitchcase"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{switch..case..}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="margin-right:0.02691em;color:red;">w</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">h</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	a := 3
	switch a {
	case 1:
		fmt.Println(&quot;First&quot;)
	case 2:
		fmt.Println(&quot;Second&quot;)
	default:
		fmt.Println(&quot;xxx&quot;)
	}
}
</code></pre>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>
<pre><code class="language-/usr/bin/env">func main() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println(&quot;奇数&quot;)
	case 2, 4, 6, 8:
		fmt.Println(&quot;偶数&quot;)
	default:
		fmt.Println(n)
	}
}
</code></pre>
<p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的.</p>
<pre><code class="language-/usr/bin/env">func main() {
	s := &quot;a&quot;
	switch {
	case s == &quot;a&quot;:
		fmt.Println(&quot;a&quot;)
		fallthrough
	case s == &quot;b&quot;:
		fmt.Println(&quot;b&quot;)
	case s == &quot;c&quot;:
		fmt.Println(&quot;c&quot;)
	default:
		fmt.Println(&quot;...&quot;)
	}
}
</code></pre>
<h3 id="colorredgoto跳转到指定标签"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>g</mi><mi>o</mi><mi>t</mi><mi>o</mi><mo>(</mo><mi mathvariant="normal">跳</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">签</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{goto(跳转到指定标签)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">o</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">跳</span><span class="mord cjk_fallback" style="color:red;">转</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">标</span><span class="mord cjk_fallback" style="color:red;">签</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(&quot;111&quot;)

	goto End //goto 是关键字。End是用户起的名字，叫做标签

	fmt.Println(&quot;222&quot;)

End:
	fmt.Println(&quot;333&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之iota]]></title>
        <id>https://jiajiaba.github.io/post/iota</id>
        <link href="https://jiajiaba.github.io/post/iota">
        </link>
        <updated>2019-09-02T01:10:47.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中iota的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中iota的基本使用</p>
<!-- more -->
<h3 id="colorrediota"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{iota}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span></span></span></span></span></h3>
<p>iota是go语言的常量计数器，只能在常量的表达式中使用<br>
iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次</p>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	n3        //2
	n4        //3
)
</code></pre>
<h3 id="colorred几个常见的iota示例"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">几</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">见</mi><mi mathvariant="normal">的</mi><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">例</mi><mo>:</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{几个常见的iota示例:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">几</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">见</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord cjk_fallback" style="color:red;">示</span><span class="mord cjk_fallback" style="color:red;">例</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span></span></span></span></span></h3>
<ul>
<li>使用_跳过某些值</li>
</ul>
<pre><code class="language-/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	_
	n4 //3
)
</code></pre>
<ul>
<li>iota声明过程中间插队</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2 = 100  //100
	n3 = iota //2
	n4        //3
)
const n5 = iota //0
</code></pre>
<ul>
<li>多个iota定义在一行</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	a, b = iota + 1, iota + 2 //1,2
	c, d                      //2,3
	e, f                      //3,4
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker常用命令]]></title>
        <id>https://jiajiaba.github.io/post/docker-chang-yong-ming-ling</id>
        <link href="https://jiajiaba.github.io/post/docker-chang-yong-ming-ling">
        </link>
        <updated>2019-08-27T01:24:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Docker的一些常用命令。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Docker的一些常用命令。</p>
 <!-- more -->
<p><strong>帮助命令：</strong></p>
<ol>
<li>docker version：显示 Docker 版本信息。</li>
<li>docker info：显示 Docker 系统信息，包括镜像和容器数。</li>
<li>docker --help 帮助命令</li>
</ol>
<p><strong>镜像命令</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>-a：列出本地所有镜像（含中间映像层）</li>
<li>-q：只显示镜像ID</li>
<li>--digests：显示镜像的摘要信息</li>
<li>--no-trunc：显示完整的镜像信息</li>
</ul>
</li>
<li>docker search  从Docker Hub查找镜像
<ul>
<li>-s：列出收藏数不小于指定的镜像</li>
<li>--no-trunc：显示完整的镜像信息</li>
<li>--automated：只列出automated build(自动构建)类型的镜像，也就是非官方的。</li>
</ul>
</li>
<li>docker pull  从Docker Hub下载镜像</li>
<li>docker rmi   删除镜像
<ul>
<li>删除单个：docker rmi -f 镜像ID</li>
<li>删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG</li>
<li>删除全部：docker rmi -f $(docker images -qa)</li>
</ul>
</li>
</ol>
<p><strong>容器命令(有镜像才能创建容器，这是根本前提)</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>--name = &quot;容器新名字&quot;，为容器指定一个名称</li>
<li>-d： 后台运行容器，并返回容器ID，即启动守护式容器</li>
<li>-i：以交互模式运行容器，通常与-t同时使用</li>
<li>-t为容器重新分配一个伪输入终端，通常与-i同时使用</li>
<li>-P：随机端口映射</li>
<li>-p：指定端口映射</li>
</ul>
</li>
<li>docker ps  列出当前正在运行的全部命令
<ul>
<li>-a：列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li>-q：静默模式，只显示容器编号</li>
<li>--no-trunc：不截断输出</li>
</ul>
</li>
<li>退出容器
<ul>
<li>exit：容器停止并且退出</li>
<li>ctrl+P+Q：容器不停止退出</li>
</ul>
</li>
<li>启动容器
<ul>
<li>docker start 容器ID或者容器名</li>
</ul>
</li>
<li>重启容器
<ul>
<li>docker restart 容器ID或者容器名</li>
</ul>
</li>
<li>停止容器
<ul>
<li>docker stop 容器ID或者容器名</li>
</ul>
</li>
<li>强制停止容器
<ul>
<li>docker kill 容器ID或者容器名</li>
</ul>
</li>
<li>删除已经停止的容器
<ul>
<li>docker rm 容器ID</li>
<li>一次性删除多个容器：docker rm -f $(docker ps -qa)</li>
</ul>
</li>
<li>启动守护式进程(即后台运行)
<ul>
<li>docker -d 容器名</li>
</ul>
</li>
<li>查看容器日志：docker logs -f --tail 容器ID
<ul>
<li>-t：是加入的时间戳</li>
<li>-f：跟随最新的日志打印</li>
<li>--tail 数字。显示最后多少条</li>
</ul>
</li>
<li>查看容器内运行的进程
<ul>
<li>docker top 容器ID</li>
</ul>
</li>
<li>查看容器内部细节
<ul>
<li>docker inspect 容器ID</li>
</ul>
</li>
<li>进入正在运行的容器，并以命令行交互
<ul>
<li>docker exec -it 容器ID /bin/bash</li>
<li>重新进入：docker attach 容器ID</li>
<li>两者区别：<br>
attach：直接进入容器启动命令的终端，不会启动新的进程。<br>
exec：是在容器中打开新的终端，并且可以启动新的进程，举例：docker exec - it 容器ID ls -l</li>
</ul>
</li>
<li>从容器内拷贝文件到主机上
<ul>
<li>docker cp 容器ID：容器内路径  目的主机路径</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>