<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiajiaba.github.io</id>
    <title>JIAJIA</title>
    <updated>2019-09-02T07:51:12.507Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiajiaba.github.io"/>
    <link rel="self" href="https://jiajiaba.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiajiaba.github.io/images/avatar.png</logo>
    <icon>https://jiajiaba.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, JIAJIA</rights>
    <entry>
        <title type="html"><![CDATA[Go语言基础之数组]]></title>
        <id>https://jiajiaba.github.io/post/shuzu</id>
        <link href="https://jiajiaba.github.io/post/shuzu">
        </link>
        <updated>2019-09-02T07:03:10.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言数组的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言数组的基本使用</p>
<!-- more -->
<h2 id="colorredarray数组定义"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></strong></h2>
<p>数组是同一种数据类型元素的集合。<br>
数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>
数组基本语法：<br>
<code>var 数组变量名 [元素数量]类型</code></p>
<pre><code class="language-/usr/bin/env">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mo>:</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">。</mi><mo>[</mo><mn>5</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">和</mi><mo>[</mo><mn>10</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{注意:数组的长度必须是常量，一旦定义，长度不能改变。[5]int和[10]int是不同类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">注</span><span class="mord cjk_fallback" style="color:red;">意</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">一</span><span class="mord cjk_fallback" style="color:red;">旦</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">改</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">。</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">5</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">1</span><span class="mord" style="color:red;">0</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></p>
<h2 id="colorredarray数组初始化"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">初</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">化</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)初始化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">初</span><span class="mord cjk_fallback" style="color:red;">始</span><span class="mord cjk_fallback" style="color:red;">化</span></span></span></span></span></h2>
<ul>
<li>初始化数组时可以使用初始化列表来设置数组元素的值。</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>让编译器根据初始值的个数自行推断数组的长度</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                          //数组会初始化为int类型的零值
	var numArray = [...]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                        //[0 0 0]
	fmt.Println(numArray)                         //[1 2 0]
	fmt.Println(cityArray)                        //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>使用指定索引值的方式来初始化数组</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{1: &quot;北京&quot;, 3: &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	fmt.Println(cityArray)                              //[ 北京  上海 深圳]
	fmt.Printf(&quot;type is %T&quot;, cityArray)                 //type is [5]string
}
</code></pre>
<h2 id="colorredarray数组遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	//for遍历
	for i := 0; i &lt; len(cityArray); i++ {
		fmt.Println(cityArray[i])
	}
	//for range遍历
	for i, data := range cityArray {
		fmt.Println(i, data)
	}
}
</code></pre>
<h2 id="colorred多维数组"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">多</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{多维数组}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">多</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span></span></span></span></span></h2>
<p>以二维数组为例</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[1][1]) //支持索引取值:深圳
}
</code></pre>
<h2 id="colorred二维数组的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{二维数组的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">二</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>
<p>输出：</p>
<pre><code>北京	上海	
广州	深圳	
成都	重庆
</code></pre>
<p>注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：</p>
<pre><code class="language-/usr/bin/env">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>
<h2 id="colorred数组是值类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{数组是值类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var x = [3]int{1, 2, 3}
	fmt.Println(x)
	f1(x)
	fmt.Println(x)
}

func f1(a [3]int) {
	a[0] = 100      //改变第一个值
}
</code></pre>
<p>输出：</p>
<pre><code>[1 2 3]
[1 2 3]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之流程控制]]></title>
        <id>https://jiajiaba.github.io/post/liuchengkongzhi</id>
        <link href="https://jiajiaba.github.io/post/liuchengkongzhi">
        </link>
        <updated>2019-09-02T03:07:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
 <!-- more -->
<h3 id="colorredifelse分支结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>(</mo><mi mathvariant="normal">分</mi><mi mathvariant="normal">支</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{if..else..(分支结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">支</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>if基本使用格式：</p>
<pre><code class="language-Go">if 表达式1 {
    分支1
} else if 表达式2 {
    分支2
} else{
    分支3
}
</code></pre>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	a:=10
	if a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>注意：Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，否则编译错误。</p>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	if a := 10; a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>另外，if语句还支持初始化语句，初始化条件和判断条件以分号分隔。但是需要注意的是，例子中a这个变量只在if语句块里面生效。</p>
<h3 id="colorredfor循环结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi mathvariant="normal">循</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{for(循环结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">循</span><span class="mord cjk_fallback" style="color:red;">环</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>for基本使用格式</p>
<pre><code>for 初始语句;条件表达式;结束语句{
			循环体语句
}
</code></pre>
<pre><code class="language-/usr/bin/env">func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<h3 id="其他特殊写法">其他特殊写法</h3>
<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for ; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<p>for循环的初始语句和结束语句都可以省略，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for i &lt; 10 {
		fmt.Println(i)
	}
}
</code></pre>
<p>无限循环，例如：</p>
<pre><code class="language-/usr/bin/env">for {
	循环语句体
}
</code></pre>
<p>for range (键值循环)使用，例如:</p>
<pre><code class="language-/usr/bin/env">func main() {
	str := &quot;abc&quot;
	for i, data := range str {
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, data)
	}

	for i := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}

	for i, _ := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}
}
</code></pre>
<h3 id="colorredswitchcase"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{switch..case..}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="margin-right:0.02691em;color:red;">w</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">h</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	a := 3
	switch a {
	case 1:
		fmt.Println(&quot;First&quot;)
	case 2:
		fmt.Println(&quot;Second&quot;)
	default:
		fmt.Println(&quot;xxx&quot;)
	}
}
</code></pre>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>
<pre><code class="language-/usr/bin/env">func main() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println(&quot;奇数&quot;)
	case 2, 4, 6, 8:
		fmt.Println(&quot;偶数&quot;)
	default:
		fmt.Println(n)
	}
}
</code></pre>
<p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的.</p>
<pre><code class="language-/usr/bin/env">func main() {
	s := &quot;a&quot;
	switch {
	case s == &quot;a&quot;:
		fmt.Println(&quot;a&quot;)
		fallthrough
	case s == &quot;b&quot;:
		fmt.Println(&quot;b&quot;)
	case s == &quot;c&quot;:
		fmt.Println(&quot;c&quot;)
	default:
		fmt.Println(&quot;...&quot;)
	}
}
</code></pre>
<h3 id="colorredgoto跳转到指定标签"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>g</mi><mi>o</mi><mi>t</mi><mi>o</mi><mo>(</mo><mi mathvariant="normal">跳</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">签</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{goto(跳转到指定标签)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">o</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">跳</span><span class="mord cjk_fallback" style="color:red;">转</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">标</span><span class="mord cjk_fallback" style="color:red;">签</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(&quot;111&quot;)

	goto End //goto 是关键字。End是用户起的名字，叫做标签

	fmt.Println(&quot;222&quot;)

End:
	fmt.Println(&quot;333&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之iota]]></title>
        <id>https://jiajiaba.github.io/post/iota</id>
        <link href="https://jiajiaba.github.io/post/iota">
        </link>
        <updated>2019-09-02T01:10:47.000Z</updated>
        <summary type="html"><![CDATA[<p>关于Go语言中iota的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于Go语言中iota的基本使用</p>
<!-- more -->
<h3 id="colorrediota"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{iota}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span></span></span></span></span></h3>
<p>iota是go语言的常量计数器，只能在常量的表达式中使用<br>
iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次</p>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	n3        //2
	n4        //3
)
</code></pre>
<h3 id="colorred几个常见的iota示例"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">几</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">见</mi><mi mathvariant="normal">的</mi><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">例</mi><mo>:</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{几个常见的iota示例:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">几</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">见</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord cjk_fallback" style="color:red;">示</span><span class="mord cjk_fallback" style="color:red;">例</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span></span></span></span></span></h3>
<ul>
<li>使用_跳过某些值</li>
</ul>
<pre><code class="language-/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	_
	n4 //3
)
</code></pre>
<ul>
<li>iota声明过程中间插队</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2 = 100  //100
	n3 = iota //2
	n4        //3
)
const n5 = iota //0
</code></pre>
<ul>
<li>多个iota定义在一行</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	a, b = iota + 1, iota + 2 //1,2
	c, d                      //2,3
	e, f                      //3,4
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker常用命令]]></title>
        <id>https://jiajiaba.github.io/post/docker-chang-yong-ming-ling</id>
        <link href="https://jiajiaba.github.io/post/docker-chang-yong-ming-ling">
        </link>
        <updated>2019-08-27T01:24:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Docker的一些常用命令。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Docker的一些常用命令。</p>
 <!-- more -->
<p><strong>帮助命令：</strong></p>
<ol>
<li>docker version：显示 Docker 版本信息。</li>
<li>docker info：显示 Docker 系统信息，包括镜像和容器数。</li>
<li>docker --help 帮助命令</li>
</ol>
<p><strong>镜像命令</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>-a：列出本地所有镜像（含中间映像层）</li>
<li>-q：只显示镜像ID</li>
<li>--digests：显示镜像的摘要信息</li>
<li>--no-trunc：显示完整的镜像信息</li>
</ul>
</li>
<li>docker search  从Docker Hub查找镜像
<ul>
<li>-s：列出收藏数不小于指定的镜像</li>
<li>--no-trunc：显示完整的镜像信息</li>
<li>--automated：只列出automated build(自动构建)类型的镜像，也就是非官方的。</li>
</ul>
</li>
<li>docker pull  从Docker Hub下载镜像</li>
<li>docker rmi   删除镜像
<ul>
<li>删除单个：docker rmi -f 镜像ID</li>
<li>删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG</li>
<li>删除全部：docker rmi -f $(docker images -qa)</li>
</ul>
</li>
</ol>
<p><strong>容器命令(有镜像才能创建容器，这是根本前提)</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>--name = &quot;容器新名字&quot;，为容器指定一个名称</li>
<li>-d： 后台运行容器，并返回容器ID，即启动守护式容器</li>
<li>-i：以交互模式运行容器，通常与-t同时使用</li>
<li>-t为容器重新分配一个伪输入终端，通常与-i同时使用</li>
<li>-P：随机端口映射</li>
<li>-p：指定端口映射</li>
</ul>
</li>
<li>docker ps  列出当前正在运行的全部命令
<ul>
<li>-a：列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li>-q：静默模式，只显示容器编号</li>
<li>--no-trunc：不截断输出</li>
</ul>
</li>
<li>退出容器
<ul>
<li>exit：容器停止并且退出</li>
<li>ctrl+P+Q：容器不停止退出</li>
</ul>
</li>
<li>启动容器
<ul>
<li>docker start 容器ID或者容器名</li>
</ul>
</li>
<li>重启容器
<ul>
<li>docker restart 容器ID或者容器名</li>
</ul>
</li>
<li>停止容器
<ul>
<li>docker stop 容器ID或者容器名</li>
</ul>
</li>
<li>强制停止容器
<ul>
<li>docker kill 容器ID或者容器名</li>
</ul>
</li>
<li>删除已经停止的容器
<ul>
<li>docker rm 容器ID</li>
<li>一次性删除多个容器：docker rm -f $(docker ps -qa)</li>
</ul>
</li>
<li>启动守护式进程(即后台运行)
<ul>
<li>docker -d 容器名</li>
</ul>
</li>
<li>查看容器日志：docker logs -f --tail 容器ID
<ul>
<li>-t：是加入的时间戳</li>
<li>-f：跟随最新的日志打印</li>
<li>--tail 数字。显示最后多少条</li>
</ul>
</li>
<li>查看容器内运行的进程
<ul>
<li>docker top 容器ID</li>
</ul>
</li>
<li>查看容器内部细节
<ul>
<li>docker inspect 容器ID</li>
</ul>
</li>
<li>进入正在运行的容器，并以命令行交互
<ul>
<li>docker exec -it 容器ID /bin/bash</li>
<li>重新进入：docker attach 容器ID</li>
<li>两者区别：<br>
attach：直接进入容器启动命令的终端，不会启动新的进程。<br>
exec：是在容器中打开新的终端，并且可以启动新的进程，举例：docker exec - it 容器ID ls -l</li>
</ul>
</li>
<li>从容器内拷贝文件到主机上
<ul>
<li>docker cp 容器ID：容器内路径  目的主机路径</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>