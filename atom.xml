<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiajia775.github.io</id>
    <title>JIAJIA</title>
    <updated>2020-11-03T16:20:26.076Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiajia775.github.io"/>
    <link rel="self" href="https://jiajia775.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiajia775.github.io/images/avatar.png</logo>
    <icon>https://jiajia775.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JIAJIA</rights>
    <entry>
        <title type="html"><![CDATA[Go语言基础之并发]]></title>
        <id>https://jiajia775.github.io/post/concurrency</id>
        <link href="https://jiajia775.github.io/post/concurrency">
        </link>
        <updated>2019-09-07T06:22:48.000Z</updated>
        <summary type="html"><![CDATA[<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
]]></summary>
        <content type="html"><![CDATA[<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
 <!-- more -->
<h2 id="colorred并行和并发的区别"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">并</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">发</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">别</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{并行和并发的区别}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">并</span><span class="mord cjk_fallback" style="color:red;">行</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">并</span><span class="mord cjk_fallback" style="color:red;">发</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">区</span><span class="mord cjk_fallback" style="color:red;">别</span></span></span></span></span></h2>
<h4 id="并行parallel指在同一时刻有多条指令在多个处理器上同时执行">并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</h4>
<p><img src="https://jiajia775.github.io/post-images/1567838533900.jpg" alt=""></p>
<h4 id="并发concurrency指在同一时刻只能有一条指令执行但多个进程指令被快速的轮换执行使得在宏观上具有多个进程同时执行的效果但在微观上并不是同时执行的只是把时间分成若干段使多个进程快速交替的执行">并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</h4>
<p><img src="https://jiajia775.github.io/post-images/1567838559318.jpg" alt=""><br>
并行就相当于两个队列同时使用两台咖啡机<br>
并发就相当于两个队列交替使用一台咖啡机<br>
<img src="https://jiajia775.github.io/post-images/1567838628453.png" alt=""></p>
<h2 id="colorredgoroutine"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>g</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{goroutine}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">u</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">e</span></span></span></span></span></h2>
<h4 id="什么是goroutine">什么是goroutine？</h4>
<p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<h4 id="创建goroutine">创建goroutine</h4>
<p>只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。<br>
在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func newTask() {
	for {
		fmt.Println(&quot;this is newTask&quot;)
		time.Sleep(time.Second)
	}
}

func main() {
	go newTask() //新建一个协程,新建一个任务,必须写在前面。
	for {
		fmt.Println(&quot;this is main&quot;)
		time.Sleep(time.Second)
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>this is main
this is newTask
this is newTask
this is main
this is newTask
this is main
...
</code></pre>
<h4 id="主goroutine退出其他的goroutine也会跟着退出">主goroutine退出，其他的goroutine也会跟着退出</h4>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

// 主协程先退出了，其他子协程也要跟着退出
func main() {

	go func() {
		i := 0
		for {
			i++
			fmt.Println(&quot;func i = &quot;, i)
			time.Sleep(time.Second)
		}
	}() //别忘了自身调用

	i := 0
	for {
		i++
		fmt.Println(&quot;main i = &quot;, i)
		time.Sleep(time.Second)
		if i == 2 {
			break
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>main i =  1
func i =  1
main i =  2
func i =  2
</code></pre>
<h2 id="colorredruntime包"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">包</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{runtime包}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">u</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">包</span></span></span></span></span></h2>
<h4 id="gosched">Gosched</h4>
<p>runtime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。<br>
这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {

	go func() {
		for i := 0; i &lt; 5; i++ {
			fmt.Println(&quot;BBB&quot;)
		}
	}()

	for i := 0; i &lt; 3; i++ {
		//让出时间片，先让别的协程执行，执行完再回来。
		runtime.Gosched()
		fmt.Println(&quot;AAA&quot;)
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>BBB
BBB
BBB
BBB
BBB
AAA
AAA
AAA
</code></pre>
<h4 id="goexit">Goexit</h4>
<p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。</p>
<ol>
<li>先来看看没有调度的情况，代码如下：</li>
</ol>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func test() {
	defer fmt.Println(&quot;ccccccccccccc&quot;)
	fmt.Println(&quot;ddddddddddddd&quot;)
}

func main() {
	go func() {
		fmt.Println(&quot;aaaaaaaaaaaaa&quot;)
		test()
		fmt.Println(&quot;bbbbbbbbbbbbb&quot;)
	}()

	//特地写一个死循环，目的不让主协程退出
	for {
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>aaaaaaaaaaaaa
ddddddddddddd
ccccccccccccc
bbbbbbbbbbbbb

</code></pre>
<ol start="2">
<li>再来看看看调度了的情况。</li>
</ol>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func test() {
	defer fmt.Println(&quot;cccccccccccc&quot;)
	//终止此函数
	// return

	//终止所在的协程
	runtime.Goexit()

	fmt.Println(&quot;dddddddddddd&quot;)
}

func main() {
	go func() {
		fmt.Println(&quot;aaaaaaaaaaaaa&quot;)
		test()
		fmt.Println(&quot;bbbbbbbbbbbbb&quot;)
	}()

	//特地写一个死循环，目的不让主协程退出
	for {
	}
}
</code></pre>
<p>输出：</p>
<pre><code>aaaaaaaaaaaaa
cccccccccccc
</code></pre>
<p>需要注意的是：案例中有return，return返回的则是a,c,b(简写)</p>
<h4 id="gomaxprocs">GOMAXPROCS</h4>
<p>调用 runtime.GOMAXPROCS() 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {
	n := runtime.GOMAXPROCS(2) //指定核数运行
	fmt.Print(&quot;n = &quot;, n)
	for {
		go fmt.Print(0)
		fmt.Print(1)
	}
}
</code></pre>
<p>输出：<br>
<code>111100000101100111111100000001111111100000000111111111000000000111111111100000000001011111111111100000000000011111111111110000000000000111111111111110000000000000011111100000011111110000000111111111111000000000000111111111111111110000000000000000011100010111111111000000000111111111000000000111111111100000000001111111111111111111111111111100000000000000000000000000000101100111111111111111111111111111111110000000000000000000000000000000011111111111111111111111</code></p>
<h4 id="多任务竞争问题">多任务竞争问题</h4>
<p>例如有一个打印机，两个人都需要使用，就会产生竞争问题，示例代码如下：</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

// 打印机
func Printer(str string) {
	for _, data := range str {
		fmt.Printf(&quot;%c&quot;, data)
		time.Sleep(time.Second)
	}
	fmt.Println(&quot;\n&quot;)
}

// 使用打印机的第一个人
func Persion1() {
	Printer(&quot;hello&quot;)
}

// 使用打印机的第二个人
func Persion2() {
	Printer(&quot;world&quot;)

}

func main() {
	go Persion1()
	go Persion2()

	//死循环,目的是让主协程无法退出
	for {

	}
}
</code></pre>
<p>输出结果：<br>
<code>wheorlllod</code></p>
<h2 id="colorredchannel"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>n</mi><mi>e</mi><mi>l</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{channel}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">h</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span></span></span></span></span></h2>
<p>用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。<br>
定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make()函数来创建：</p>
<pre><code>make(chan type)
make(chan type,capacity)
</code></pre>
<p>以上两种区别在于有无缓冲区，稍后做介绍。<br>
利用channel解决打印机竞争的问题</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)
//创建通道
var ch = make(chan int)

func Printer(str string) {
	for _, data := range str {
		fmt.Printf(&quot;%c&quot;, data)
		time.Sleep(time.Second)
	}
	fmt.Println(&quot;\n&quot;)
}

// 多任务执行，打印完再存数据到通道里面
func Persion1() {
	Printer(&quot;hello&quot;)
	ch &lt;- 666
}

// 多任务执行，通道会取数据，若通道里面没有数据，则会阻塞。
func Persion2() {
	&lt;-ch
	Printer(&quot;world&quot;)

}

func main() {
	go Persion1()
	go Persion2()

	for {

	}
}
</code></pre>
<p>再举例：</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	var ch = make(chan string)
	go func() {
		defer fmt.Println(&quot;子协程调用完毕&quot;)
		for i := 0; i &lt; 2; i++ {
			fmt.Println(&quot;i = &quot;, i)
			time.Sleep(time.Second)
		}
		ch &lt;- &quot;子协程执行完毕&quot;
	}()

	str := &lt;-ch
	fmt.Println(str)
	fmt.Println(&quot;主协程结束&quot;)
}
</code></pre>
<p>输出：</p>
<pre><code>子协程正在运行
子协程调用完毕
子协程执行完毕
主协程执行完毕
</code></pre>
<h4 id="无缓冲区的channel">无缓冲区的channel</h4>
<p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。</p>
<p>这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。</p>
<p>这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。<br>
<img src="https://jiajia775.github.io/post-images/1567909155237.png" alt=""></p>
<ul>
<li>在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。</li>
<li>在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。</li>
<li>在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。</li>
<li>在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。<br>
示例代码：</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	c := make(chan int, 0) //无缓冲的通道

	//内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小
	fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))

	go func() {
		defer fmt.Println(&quot;子协程结束&quot;)

		for i := 0; i &lt; 3; i++ {
			c &lt;- i
			fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))
		}
	}()

	time.Sleep(2 * time.Second) //延时2s

	for i := 0; i &lt; 3; i++ {
		num := &lt;-c //从c中接收数据，并赋值给num
		fmt.Println(&quot;num = &quot;, num)
	}

	fmt.Println(&quot;main协程结束&quot;)
}
</code></pre>
<p>输出：</p>
<pre><code>len(c)=0, cap(c)=0
子协程正在运行[0]: len(c)=0, cap(c)=0
num =  0
num =  1
子协程正在运行[1]: len(c)=0, cap(c)=0
子协程正在运行[2]: len(c)=0, cap(c)=0
子协程结束
num =  2
main协程结束
</code></pre>
<p>此输出结果将会在第一行结果出来之后阻塞，原因是存进管道的时候阻塞了，所以到达sleep两秒的代码。还需注意，无缓冲通道的len和cap都为0.</p>
<h4 id="有缓冲的通道buffered-channel">有缓冲的通道（buffered channel）</h4>
<p>是一种在被接收前能存储一个或者多个值的通道。</p>
<p>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p>
<p>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。<br>
<img src="https://jiajia775.github.io/post-images/1567910289527.png" alt=""></p>
<ul>
<li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li>
<li>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。</li>
<li>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。</li>
<li>最后，在第 4 步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	c := make(chan int, 3) //无缓冲的通道

	//内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小
	fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))

	go func() {
		defer fmt.Println(&quot;子协程结束&quot;)

		for i := 0; i &lt; 3; i++ {
			c &lt;- i
			fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))
		}
	}()

	time.Sleep(2 * time.Second) //延时2s

	for i := 0; i &lt; 3; i++ {
		num := &lt;-c //从c中接收数据，并赋值给num
		fmt.Println(&quot;num = &quot;, num)
	}

	fmt.Println(&quot;main协程结束&quot;)
}
</code></pre>
<p>输出结果：</p>
<pre><code>len(c)=0, cap(c)=3
子协程正在运行[0]: len(c)=1, cap(c)=3
子协程正在运行[1]: len(c)=2, cap(c)=3
子协程正在运行[2]: len(c)=3, cap(c)=3
子协程结束
num =  0
num =  1
num =  2
main协程结束
</code></pre>
<h4 id="关闭管道">关闭管道</h4>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i &lt; 5; i++ {
			ch &lt;- i //往通道写数据
		}
		//不需要再写数据时，关闭channel
		close(ch)
	}()

	for {
		//如果ok==true说明管道没有关闭
		if num, ok := &lt;-ch; ok == true {
			fmt.Println(&quot;num = &quot;, num)
		} else { //管道关闭
			break
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>num =  0
num =  1
num =  2
num =  3
num =  4
</code></pre>
<p>也可以使用range的用法，示例如下：</p>
<pre><code class="language-/usr/bin/env">func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i &lt; 5; i++ {
			ch &lt;- i //往通道写数据
		}
		//不需要再写数据时，关闭channel
		close(ch)
	}()

	for num := range ch {
		fmt.Println(&quot;num = &quot;, num)
	}
</code></pre>
<p>}</p>
<h4 id="单方向的channnel">单方向的channnel</h4>
<pre><code class="language-/usr/bin/env">func main() {
	ch := make(chan int)

	//双向通道能够隐式转换为单向通道
	var whirech chan&lt;- int = ch
	whirech &lt;- 666 //写

	var readch &lt;-chan int = ch
	&lt;-readch //读
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之time包]]></title>
        <id>https://jiajia775.github.io/post/time</id>
        <link href="https://jiajia775.github.io/post/time">
        </link>
        <updated>2019-09-06T07:12:54.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言内置的time包的基本用法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言内置的time包的基本用法。</p>
<!-- more -->
<h2 id="colorredtime包"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">包</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{time包}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">包</span></span></span></span></span></h2>
<p>time包提供了时间的显示和测量用的函数。日历的计算采用的是公历</p>
<h4 id="时间类型">时间类型</h4>
<p>time.Time类型表示时间。<br>
可以通过time.Now()函数获取当前的时间对象</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	now := time.Now() //获取当前时间
	fmt.Println(now)  //2019-09-06 15:18:44.253201 +0800 CST m=+0.006002601

	year := now.Year()            //年
	month := now.Month()          //月
	day := now.Day()              //日
	fmt.Println(year, month, day) //2019 September 6
}
</code></pre>
<h4 id="时间戳">时间戳</h4>
<p>时间戳是自1970年1月1日（08: 00 :00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	now := time.Now()    //获取当前时间
	t1 := now.Unix()     //时间戳
	t2 := now.UnixNano() //纳秒时间戳
	fmt.Println(t1)      //1567755290
	fmt.Println(t2)      //1567755290965926000

	//将时间戳转换为时间格式
	t3 := time.Unix(t1, 0) //第一个参数当前时间戳，第二个参数要添加的时间戳。
	fmt.Println(t3)        //2019-09-06 15:34:50 +0800 CST
}
</code></pre>
<h4 id="时间间隔">时间间隔</h4>
<p>time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔</p>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(1)
	time.Sleep(5) //5这个单位是纳秒
	fmt.Println(2)
	time.Sleep(5 * time.Second) //这个才是间隔5秒
	fmt.Println(3)

	//如果定义了一个变量
	n := 5
	time.Sleep(time.Duration(n) * time.Second) //需要强制转换
	fmt.Println(&quot;over&quot;)
}
</code></pre>
<h4 id="时间操作">时间操作</h4>
<pre><code class="language-/usr/bin/env">func main() {
	//当前时间加一个小时
	now := time.Now()
	later := now.Add(time.Hour)
	fmt.Println(now)   //2019-09-06 15:50:27.4478881 +0800 CST m=+0.002008301
	fmt.Println(later) //2019-09-06 16:50:27.4478881 +0800 CST m=+3600.002008301

	//时间相减
	t := later.Sub(now)
	fmt.Println(t) //1h0m0s
}
</code></pre>
<h4 id="定时器">定时器</h4>
<p>使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel）。</p>
<pre><code class="language-/usr/bin/env">func main() {
	for t := range time.Tick(time.Second) { //定义一个1秒间隔的定时器
		fmt.Println(t) //每秒都会执行的任务
	}
}
</code></pre>
<h4 id="时间格式化">时间格式化</h4>
<p>时间类型有一个自带的方法Format进行格式化，需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。</p>
<pre><code class="language-/usr/bin/env">func main() {
	now := time.Now()
	fmt.Println(now)

	//时间格式化：Y      m   d   H   M   S
	//GO语言中   2006   01  02  15  04  05
	t1 := now.Format(&quot;2006-01-02 15-04-05&quot;)
	fmt.Println(t1) //2019-09-06 16-04-30

	t2 := now.Format(&quot;2006.01.02 15:04:05&quot;)
	fmt.Println(t2) //2019.09.06 16:04:30
}
</code></pre>
<h4 id="解析字符串格式">解析字符串格式</h4>
<pre><code class="language-/usr/bin/env">func main() {
	now := time.Now()
	fmt.Println(now)
	// 加载时区
	loc, err := time.LoadLocation(&quot;Asia/Shanghai&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	// 按照指定时区和指定格式解析字符串时间
	// 采用时区的方法
	timeObj, err := time.ParseInLocation(&quot;2006/01/02 15: 04 : 05&quot;, &quot;2019/08/04 14: 15 : 20&quot;, loc)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj)

	// 没有采用时区的方法
	timeObj2, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, &quot;2019/08/04 14:15:20&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj2)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之文件操作]]></title>
        <id>https://jiajia775.github.io/post/document</id>
        <link href="https://jiajia775.github.io/post/document">
        </link>
        <updated>2019-09-05T06:58:14.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中文件读写的相关操作。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中文件读写的相关操作。</p>
<!-- more --> 
<h2 id="colorred打开和关闭文件"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">打</mi><mi mathvariant="normal">开</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">闭</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{打开和关闭文件}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">打</span><span class="mord cjk_fallback" style="color:red;">开</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">关</span><span class="mord cjk_fallback" style="color:red;">闭</span><span class="mord cjk_fallback" style="color:red;">文</span><span class="mord cjk_fallback" style="color:red;">件</span></span></span></span></span></h2>
<p>os.Open()函数能够打开一个文件，返回一个* File和一个err。对得到的文件实例调用close()方法能够关闭文件。后面讲到的OpenFile()可以写入文件。</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;os&quot;

func main() {
	// 只读方式打开当前目录下的xxx.txt文件
	file,err:=os.Open(&quot;xxx.txt&quot;)
	if err:= nil{
		fmt.Println(err)
		return
	}
	//为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。
	defer file.Close()
}
</code></pre>
<h2 id="colorred读取文件"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">读</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{读取文件}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">读</span><span class="mord cjk_fallback" style="color:red;">取</span><span class="mord cjk_fallback" style="color:red;">文</span><span class="mord cjk_fallback" style="color:red;">件</span></span></span></span></span></h2>
<h4 id="基本使用">基本使用</h4>
<pre><code class="language-/usr/bin/env">func main() {
	// 只读方式打开当前目录下的xxx.txt文件
	file, err := os.Open(&quot;xxx.txt&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	//为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。
	defer file.Close()

	//读取文件
	var tmp = make([]byte, 128)
	n, err := file.Read(tmp)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf(&quot;读取了%d个字节\n&quot;, n)
	fmt.Println(string(tmp[:n]))
}
</code></pre>
<h4 id="循环读取">循环读取</h4>
<pre><code class="language-/usr/bin/env">import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	// 只读方式打开当前目录下的xxx.txt文件
	file, err := os.Open(&quot;xxx.txt&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	//为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。
	defer file.Close()

	//循环读取文件
	for {
		var tmp = make([]byte, 128)//开辟一个128字节的slice作为缓冲
		//Read返回的是一个字节数和一个错误
		n, err := file.Read(tmp)
		if err == io.EOF {
			//把当前读了多少个字节的数据打印出来，然后退出
			fmt.Println(string(tmp[:n]))
			return
		}
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Printf(&quot;读取了%d个字节\n&quot;, n)
		fmt.Println(string(tmp[:n]))
	}
}
</code></pre>
<h4 id="bufio循环读取文件">bufio循环读取文件</h4>
<p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	f, err := os.Open(&quot;./xxx.txt&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()

	//循环读取文件
	//新建一个缓冲区，返回的是一个读的对象
	reader := bufio.NewReader(f)
	for {
		//
		line, err := reader.ReadString('\n')
		if err == io.EOF {
			fmt.Print(line)
			return
		}
		if err != nil {
			return
		}
		fmt.Print(line)
	}
}
</code></pre>
<h4 id="ioutil读取整个文件">ioutil读取整个文件</h4>
<p>io/ioutil包的ReadFile方法能够读取完整的文件，只需要将文件名作为参数传入。</p>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main() {

	//读取文件
	content, err := ioutil.ReadFile(&quot;./xxx.txt&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(content))
}
</code></pre>
<h2 id="colorred写入文件"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">写</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{写入文件}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">写</span><span class="mord cjk_fallback" style="color:red;">入</span><span class="mord cjk_fallback" style="color:red;">文</span><span class="mord cjk_fallback" style="color:red;">件</span></span></span></span></span></h2>
<p>os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入。</p>
<pre><code class="language-/usr/bin/env">func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	...
}
</code></pre>
<ul>
<li>name：要打开的文件名</li>
<li>perm：文件的权限，一个八进制数，r（读）04，w（写）02，x（执行）01。</li>
<li>flag：文件打开的模式，具体如下表<br>
<img src="https://jiajia775.github.io/post-images/1567685779306.png" alt=""></li>
</ul>
<h4 id="write和writestring">Write和WriteString</h4>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	//写入文件
	fileObj, err := os.OpenFile(&quot;yyy.txt&quot;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fileObj.Close()
	fileObj.WriteString(&quot;hello go\n&quot;) //直接写入字符串数据
	str := &quot;hello jiajia&quot;
	fileObj.Write([]byte(str)) //写入字节切片数据
}
</code></pre>
<h4 id="bufionewwriter">bufio.NewWriter</h4>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	//写入文件
	fileObj, err := os.OpenFile(&quot;zzz.txt&quot;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fileObj.Close()

	writer := bufio.NewWriter(fileObj)
	for i := 0; i &lt; 10; i++ {
		writer.WriteString(&quot;hello jiajia\n&quot;) //将数据先写入缓冲区
	}
	writer.Flush() //将缓存区中的内容写入文件
}
</code></pre>
<h4 id="ioutilwritefile">ioutil.WriteFile</h4>
<pre><code class="language-/usr/bin/env">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main() {
	str := &quot;hello jiajia&quot;
	err := ioutil.WriteFile(&quot;./aaa.txt&quot;, []byte(str), 0666)
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
		return
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之面向对象编程]]></title>
        <id>https://jiajia775.github.io/post/Object</id>
        <link href="https://jiajia775.github.io/post/Object">
        </link>
        <updated>2019-09-04T02:43:05.000Z</updated>
        <summary type="html"><![CDATA[<p>尽管Go语言中没有封装、继承、多态这些概念，但同样通过别的方式实现这些特性：</p>
<ul>
<li>封装：通过方法实现</li>
<li>继承：通过匿名字段实现</li>
<li>多态：通过接口实现</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>尽管Go语言中没有封装、继承、多态这些概念，但同样通过别的方式实现这些特性：</p>
<ul>
<li>封装：通过方法实现</li>
<li>继承：通过匿名字段实现</li>
<li>多态：通过接口实现</li>
</ul>
<!-- more -->
<h2 id="colorred继承"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">继</mi><mi mathvariant="normal">承</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{继承}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">继</span><span class="mord cjk_fallback" style="color:red;">承</span></span></span></span></span></h2>
<h4 id="匿名字段">匿名字段</h4>
<pre><code class="language-/usr/bin/env">type Person struct {
	id   int
	name string
}

type Student struct {
	Person // 匿名字段，那么默认Student就包含了Person的所有字段
	add    string
}

func main() {
	//1.0
	var s1 Student = Student{Person{1, &quot;jiajia&quot;}, &quot;sz&quot;}
	fmt.Printf(&quot;s1:%#v\n&quot;, s1)

	//自动推到类型
	s2 := Student{Person{2, &quot;jiajia&quot;}, &quot;gz&quot;}
	fmt.Printf(&quot;s2:%#v\n&quot;, s2)

	s3 := Student{Person{id: 3}, &quot;bj&quot;}
	fmt.Printf(&quot;s3:%#v\n&quot;, s3)

	//成员操作
	var s4 Student
	s4.Person = Person{4, &quot;jiajia&quot;}
	s4.add = &quot;sh&quot;
	fmt.Printf(&quot;s4:%#v\n&quot;, s4)
}
</code></pre>
<h4 id="同名字段">同名字段</h4>
<pre><code class="language-/usr/bin/env">//人
type Person struct {
	name string
	age  int
	sex  byte
}

//学生
type Student struct {
	Person //只有类型，没有名字，匿名字段，继承了Person的成员
	add    string
	id     int
	name   string //跟Person同名了，即为同名字段
}

func main() {
	var s1 Student
	//就近原则
	s1.name = &quot;Go&quot; //s1 = {Person:{name: age:0 sex:0} add:sz id:1 name:Go}
	s1.add = &quot;sz&quot;
	s1.id = 1
	fmt.Printf(&quot;s1 = %+v\n&quot;, s1)
	s1.Person.name = &quot;jiajia&quot;
	fmt.Printf(&quot;s1 = %+v\n&quot;, s1) //s1 = {Person:{name:jiajia age:0 sex:0} add:sz id:1 name:Go}
}
</code></pre>
<h4 id="非结构体字段的操作">非结构体字段的操作</h4>
<pre><code class="language-/usr/bin/env">type mystring string //自定义类型

//人
type Person struct {
	name string
	age  int
	sex  byte
}

//学生
type Student struct {
	Person //匿名字段
	int    //基础类型的匿名字段
	mystring
}

func main() {
	var s Student
	s.Person = Person{&quot;jiajia&quot;, 18, 'm'}
	s.int = 2
	s.mystring = &quot;hello go&quot;
	fmt.Printf(&quot;s = %+v\n&quot;, s)

	s2 := Student{Person{&quot;jiajia&quot;, 18, 'm'}, 2, &quot;hello go&quot;}
	fmt.Println(s2)
}
</code></pre>
<h4 id="结构体指针类型匿名字段">结构体指针类型匿名字段</h4>
<pre><code class="language-/usr/bin/env">type mystring string //自定义类型

//人
type Person struct {
	name string
	age  int
	sex  byte
}

//学生
type Student struct {
	*Person //指针类型------匿名字段
	int     //基础类型的匿名字段
	mystring
}

func main() {
	//1，0 方法一
	var s Student
	s.Person = &amp;Person{&quot;JIAJIA&quot;, 18, 'm'}
	s.int = 1
	s.mystring = &quot;hello go&quot;
	fmt.Printf(&quot;s = %+v\n&quot;, s) //s = {Person:0xc000004480 int:2 mystring:hello go}
	fmt.Println(s.name, s.age, s.sex)

	// 2.0 方法二
	var s2 Student
	s2.Person = new(Person)
	s2.name = &quot;Go&quot;
	s2.age = 18
	s2.sex = 'm'
	s2.int = 2
	s2.mystring = &quot;hello go&quot;
	fmt.Printf(&quot;s2 = %+v\n&quot;, s2)

	//3.0 方法三
	s3 := Student{&amp;Person{name: &quot;Go&quot;, age: 18, sex: 'm'}, 3, &quot;hello go&quot;}
	fmt.Printf(&quot;s3 = %+v\n&quot;, s3)
}
</code></pre>
<p>输出结果：</p>
<pre><code>s = {Person:0xc000004480 int:1 mystring:hello go}
JIAJIA 18 109
s2 = {Person:0xc0000044e0 int:2 mystring:hello go}
s3 = {Person:0xc000004520 int:3 mystring:hello go}
</code></pre>
<h2 id="colorred封装"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{封装}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">封</span><span class="mord cjk_fallback" style="color:red;">装</span></span></span></span></span></h2>
<h4 id="方法">方法</h4>
<p>带有接收者的函数，我们称为方法(method)。 本质上，一个方法则是一个和特殊类型关联的函数。</p>
<pre><code class="language-/usr/bin/env">//面向对象，方法：给某个类型绑定一个函数
type bigInt int

//a 叫做接收者，接收者就是传递的一个参数
func (a bigInt) Add(b bigInt) bigInt {
	return a + b
}

func main() {
	//定义一个变量
	var a bigInt = 2
	//调用方式：变量名.函数(所需参数)
	result := a.Add(3)
	fmt.Println(&quot;result = &quot;, result)
}
</code></pre>
<h4 id="结构体类型添加方法">结构体类型添加方法</h4>
<pre><code class="language-/usr/bin/env">type myint int

type Person struct {
	id   int
	name string
}

//打印
func (p Person) Printinfo() {
	fmt.Println(p)
}

//改变内容
func (p *Person) changeinfo(i int, n string) {
	p.id = i
	p.name = n
	fmt.Println(&quot;内部:&quot;, *p)
}

func main() {
	p1 := Person{1, &quot;jiajia&quot;}
	//调用打印的方法
	p1.Printinfo()

	//调用改变的方法
	(&amp;p1).changeinfo(2, &quot;hello&quot;) //取地址操作等价于p1.changeinfo(2, &quot;hello&quot;)
	fmt.Println(&quot;外部:&quot;, p1)
</code></pre>
<p>输出结果：</p>
<pre><code>{1 jiajia}
内部: {2 hello}
外部: {2 hello}
</code></pre>
<h4 id="方法集">方法集</h4>
<pre><code class="language-/usr/bin/env">type Person struct {
	name string
	age  int
	sex  byte
}

//指针方法，非指针方法都能调用。

func (p Person) SetInfoValue() {
	fmt.Printf(&quot;SetInfoValue\n&quot;)
}

func (p *Person) SetInfoPointer() {
	fmt.Printf(&quot;SetInfoPointer\n&quot;)
}

func main() {
	//结构体变量是一个指针变量，它能够调用哪些方法，这些方法就是一个集合，简称方法集
	s1 := &amp;Person{&quot;jiajia&quot;, 18, 'm'}
	s1.SetInfoValue()
	(*s1).SetInfoValue() //(*s)转换成s后调用。等价于24行

	s2 := Person{&quot;jiajia&quot;, 18, 'm'}
	s2.SetInfoPointer() // 内部先把s转换为&amp;s再调用。相当于(&amp;s).SetInfoPointer()
	(&amp;s2).SetInfoPointer()
}
</code></pre>
<h4 id="方法的继承">方法的继承</h4>
<pre><code class="language-/usr/bin/env">type Person struct {
	name string
	age  int
	sex  byte
}

//有个学生，继承了Person字段，成员和方法都继承了
type Student struct {
	Person //匿名字段
	id     int
	addr   string
}

//Person类型，实现了一个打印输出的方法
func (tmp *Person) PrintInfo() {
	fmt.Printf(&quot;name = %s,age = %d,sex = %c\n&quot;, tmp.name, tmp.age, tmp.sex)
}

func main() {
	s := &amp;Student{Person{&quot;jiajia&quot;, 18, 'm'}, 2, &quot;sz&quot;}
	s.PrintInfo()
}
</code></pre>
<h4 id="方法的重写">方法的重写</h4>
<pre><code class="language-/usr/bin/env">type Person struct {
	name string
	age  int
	sex  byte
}

//Person类型，实现了一个打印输出的方法
func (tmp *Person) PrintInfo() {
	fmt.Printf(&quot;name = %s,age = %d,sex = %c\n&quot;, tmp.name, tmp.age, tmp.sex)
}

//有个学生，继承了Person字段，成员和方法都继承了
type Student struct {
	Person //匿名字段
	id     int
	addr   string
}

//这个学生也有自己的一个方法，这个方法和Person的方法同名，这种方法叫做重写
func (stu Student) PrintInfo() {
	fmt.Printf(&quot;name = %s,age = %d,sex = %c,id = %d,addr = %s\n&quot;, stu.name, stu.age, stu.sex, stu.id, stu.addr)
}

func main() {
	s := &amp;Student{Person{&quot;jiajia&quot;, 18, 'm'}, 2, &quot;sz&quot;}
	//就近原则
	s.PrintInfo() //调用的就是Student的方法
	//显示调用即可调用为Person方法
	//调用的就是Person的方法
	s.Person.PrintInfo()
}
</code></pre>
<p>输出结果:</p>
<pre><code>name = jiajia,age = 18,sex = m,id = 2,addr = sz
name = jiajia,age = 18,sex = m
</code></pre>
<h4 id="方法值和方法表达式">方法值和方法表达式</h4>
<pre><code class="language-/usr/bin/env">type Person struct {
	name string
	age  int
	sex  byte
}

func (p Person) SetInfoValue() {
	fmt.Printf(&quot;SetInfoValue:%p,%v\n&quot;, &amp;p, p)
}

func (p *Person) SetInfoPointer() {
	fmt.Printf(&quot;SetInfoPointer:%p,%v\n&quot;, p, p)
}

func main() {
	p := Person{&quot;jiajia&quot;, 18, 'm'}

	//方法值,隐藏了接收者
	f := p.SetInfoPointer
	f()
	//方法表达式
	f1 := (Person).SetInfoValue
	f1(p) //显式的把接收者传递过去 ==============》等价于p.SetInfoValue()

	f2 := (*Person).SetInfoPointer
	f2(&amp;p) //显式的把接收者传递过去 ==============》等价于p.SetInfoPointer()
}
</code></pre>
<h2 id="colorred多态"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">多</mi><mi mathvariant="normal">态</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{多态}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">多</span><span class="mord cjk_fallback" style="color:red;">态</span></span></span></span></span></h2>
<h4 id="接口的定义和实现">接口的定义和实现</h4>
<pre><code class="language-/usr/bin/env">type Humaner interface {
	//方法，只有声明，没有实现。由别的类型(自定义类型)实现
	sayhi()
}

type Student struct {
	name string
	id   int
}

//实现学生的方法
func (stu *Student) sayhi() {
	fmt.Printf(&quot;stu:%s,%d\n&quot;, stu.name, stu.id)
}

type Teacher struct {
	addr string
	lg   string
}

//实现老师的方法
func (tea *Teacher) sayhi() {
	fmt.Printf(&quot;tea:%s,%s\n&quot;, tea.addr, tea.lg)
}

type Str string

//实现Str的方法
func (tmp *Str) sayhi() {
	fmt.Printf(&quot;hello %s\n&quot;, *tmp)
}

func main() {
	//定义接口类型的变量
	var i Humaner

	//只要实现了此接口方法的类型，那么这个类型的变量(接收者类型)就可以赋值给i

	stu := &amp;Student{&quot;jiajia&quot;, 2} //取Student的地址赋值给stu
	i = stu                      //stu赋值给i
	i.sayhi()                    //i是接口类型，可以调用方法

	tea := &amp;Teacher{&quot;SZ&quot;, &quot;GO&quot;}
	i = tea
	i.sayhi()

	var str Str = &quot;jiajia&quot;
	i = &amp;str
	i.sayhi()

}
</code></pre>
<p>输出结果：</p>
<pre><code>stu:jiajia,2
tea:SZ,GO
hello jiajia
</code></pre>
<h4 id="多态的使用">多态的使用</h4>
<pre><code class="language-/usr/bin/env">type Humaner interface {
	//方法，只有声明，没有实现。由别的类型(自定义类型)实现
	sayhi()
}

type Student struct {
	name string
	id   int
}

//实现学生的方法
func (stu *Student) sayhi() {
	fmt.Printf(&quot;stu:%s,%d\n&quot;, stu.name, stu.id)
}

type Teacher struct {
	addr string
	lg   string
}

//实现老师的方法
func (tea *Teacher) sayhi() {
	fmt.Printf(&quot;tea:%s,%s\n&quot;, tea.addr, tea.lg)
}

type Str string

//实现Str的方法
func (tmp *Str) sayhi() {
	fmt.Printf(&quot;hello %s\n&quot;, *tmp)
}

//定义一个普通的函数，函数的参数为接口类型
//只有一个函数，可以有不同表现，多态
func myfunc(i Humaner) {
	i.sayhi()
}

func main() {
	stu := &amp;Student{&quot;jiajia&quot;, 2}
	tea := &amp;Teacher{&quot;SZ&quot;, &quot;Go&quot;}
	var str Str = &quot;jiajia&quot;
	//调用同一个函数，不同表现，多种形态
	myfunc(stu)
	myfunc(tea)
	myfunc(&amp;str)
	//定义一个切片
	x := make([]Humaner, 3)
	x[0] = stu
	x[1] = tea
	x[2] = &amp;str
	for _, i := range x {
		i.sayhi()
	}
}
</code></pre>
<h4 id="接口的继承">接口的继承</h4>
<pre><code class="language-/usr/bin/env">type Humaner interface {
	sing()
}

type Personer interface {
	Humaner //匿名字段,继承了sing()
	run(length int)
}

type Student struct {
	name string
	id   int
}

func (stu *Student) sing() {
	fmt.Println(&quot;stu会唱歌&quot;)
}

func (stu *Student) run(length int) {
	fmt.Printf(&quot;stu会跑%d米\n&quot;, length)
}

func main() {
	var i Personer
	stu := &amp;Student{&quot;jiajia&quot;, 2}
	i = stu
	i.run(100)
	pfunc := i.sing //继承过来的方法，并且使用方法值隐藏接收者变量的传递
	pfunc()
}
</code></pre>
<h4 id="空接口">空接口</h4>
<p>空接口(interface{})不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。</p>
<pre><code class="language-/usr/bin/env">func test(args ...interface{}) {
	fmt.Printf(&quot;我是接口类型:%T\n值为:%v&quot;, args, args)
}

func main() {
	//空接口，万能类型,能够保存任意类型的值
	var i interface{} = 1
	fmt.Println(&quot;i = &quot;, i)          //i =  1
	fmt.Printf(&quot;i type is %T\n&quot;, i) //i type is int

	i = true
	fmt.Println(&quot;i = &quot;, i)          //i =  true
	fmt.Printf(&quot;i type is %T\n&quot;, i) //i type is bool

	test(&quot;jiajia&quot;, 1, 2, 'm')
}
</code></pre>
<h4 id="类型断言类型查询">类型断言(类型查询)</h4>
<p>反向知道这个变量存储的是什么类型的变量<br>
if方法：</p>
<pre><code class="language-/usr/bin/env">type Student struct {
	name string
	id   int
}

func main() {
	i := make([]interface{}, 3)
	i[0] = 1
	i[1] = &quot;hello go&quot;
	i[2] = Student{&quot;jiajia&quot;, 2}

	//类型查询，类型断言
	//第一个返回的是下标，第二个返回的是值
	for index, data := range i {
		//第一个返回的是值，第二个返回的是判断结果的真假
		if value, ok := data.(int); ok == true {
			fmt.Printf(&quot;i[%d]的类型为int,值为%d\n&quot;, index, value)
		} else if value, ok := data.(string); ok == true {
			fmt.Printf(&quot;i[%d]的类型为string,值为%s\n&quot;, index, value)
		} else if value, ok := data.(Student); ok == true {
			fmt.Printf(&quot;i[%d]Student,值为name = %s,id = %d\n&quot;, index, value.name, value.id)
		}
	}
}
</code></pre>
<p>switch方法：</p>
<pre><code class="language-/usr/bin/env">type Student struct {
	name string
	id   int
}

func main() {
	i := make([]interface{}, 3)
	i[0] = 1
	i[1] = &quot;hello go&quot;
	i[2] = Student{&quot;jiajia&quot;, 2}
	for index, data := range i {
		//需要注意的是data.(type)
		switch value := data.(type) {
		case int:
			fmt.Printf(&quot;i[%d]的类型为int,值为%d\n&quot;, index, value)
		case string:
			fmt.Printf(&quot;i[%d]的类型为string,值为%s\n&quot;, index, value)
		case Student:
			fmt.Printf(&quot;i[%d]Student,值为name = %s,id = %d\n&quot;, index, value.name, value.id)
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之结构体]]></title>
        <id>https://jiajia775.github.io/post/struct</id>
        <link href="https://jiajia775.github.io/post/struct">
        </link>
        <updated>2019-09-04T00:53:35.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。</p>
<!-- more -->
<h4 id="colorred结构体的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{结构体的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">体</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h4>
<pre><code class="language-/usr/bin/env">type 类型名 struct {
    字段名 字段类型
    字段名 字段类型
    …
}
</code></pre>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>
<p>举个例子，定义一个Student(学生)结构体，代码如下</p>
<pre><code class="language-/usr/bin/env">type Student struct {
	id   int
	age  int
	name string
	add  string
}
</code></pre>
<h2 id="colorred结构体实例化"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">化</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{结构体实例化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">体</span><span class="mord cjk_fallback" style="color:red;">实</span><span class="mord cjk_fallback" style="color:red;">例</span><span class="mord cjk_fallback" style="color:red;">化</span></span></span></span></span></h2>
<p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。格式如下：<br>
<code>var 结构体实例 结构体类型</code></p>
<h4 id="基础类型结构体实例化">基础类型结构体实例化</h4>
<pre><code class="language-/usr/bin/env">type Student struct {
	id   int
	age  int
	name string
	add  string
}

func main() {
	//顺序初始化
	var s1 Student = Student{1, 18, &quot;jiajia&quot;, &quot;sz&quot;}
	fmt.Printf(&quot;%#v\n&quot;, s1) //main.Student{id:1, age:18, name:&quot;jiajia&quot;, add:&quot;sz&quot;}

	//部分初始化
	var s2 Student = Student{
		id:   2,
		name: &quot;jiajia&quot;,
	}
	fmt.Printf(&quot;%#v&quot;, s2) //main.Student{id:2, age:0, name:&quot;jiajia&quot;, add:&quot;&quot;}
}
</code></pre>
<p>也可以通过&quot;.&quot;点操作来初始化</p>
<pre><code class="language-/usr/bin/env">type Student struct {
	id   int
	age  int
	name string
	add  string
}

func main() {
	//定义一个结构体变量
	var s Student
	//操作成员使用(.)操作
	s.name = &quot;jiajia&quot;
	s.age = 18

	fmt.Printf(&quot;%#v&quot;, s) //main.Student{id:0, age:18, name:&quot;jiajia&quot;, add:&quot;&quot;}
}
</code></pre>
<h4 id="指针类型结构体实例化">指针类型结构体实例化</h4>
<pre><code class="language-/usr/bin/env">type Student struct {
	id   int
	age  int
	name string
	add  string
}

func main() {
	//和08同样效果
	var s1 *Student = &amp;Student{1, 18, &quot;jiajia&quot;, &quot;sz&quot;}
	fmt.Printf(&quot;%#v\n&quot;, *s1) //main.Student{id:1, age:18, name:&quot;jiajia&quot;, add:&quot;sz&quot;}

	//部分初始化
	var s2 *Student = &amp;Student{
		id:   2,
		name: &quot;jiajia&quot;,
		age:  19,
		add:  &quot;gz&quot;,
	}
	fmt.Printf(&quot;%#v\n&quot;, *s2) //main.Student{id:2, age:19, name:&quot;jiajia&quot;, add:&quot;gz&quot;}
}
</code></pre>
<p>也可以这样操作，注意3.0，代码如下：</p>
<pre><code class="language-/usr/bin/env">//Student 是一个结构体
type Student struct {
	id   int
	age  int
	name string
	add  string
}

func main() {
	//1.0
	//定义一个结构体变量
	var s Student
	//定义一个结构体的指针变量，保存s的值
	var p1 *Student
	p1 = &amp;s
	p1.add = &quot;sz&quot;
	p1.name = &quot;jiajia&quot;
	p1.age = 18
	fmt.Printf(&quot;s = %#v\n&quot;, s)
	fmt.Printf(&quot;*p1 = %#v\n&quot;, *p1)

	//2.0
	//通过new申请一个结构体
	p2 := new(Student)
	p2.age = 19
	p2.name = &quot;jiajia&quot;
	p2.add = &quot;gz&quot;
	fmt.Printf(&quot;*p2 = %#v\n&quot;, *p2)

	p3 := &amp;Student{
		id:   3,
		age:  20,
		name: &quot;jiajia&quot;,
		add:  &quot;bj&quot;,
	}
	fmt.Printf(&quot;*p3 = %#v\n&quot;, *p3)
}
</code></pre>
<p>输出结果：</p>
<pre><code>s = main.Student{id:0, age:18, name:&quot;jiajia&quot;, add:&quot;sz&quot;}
*p1 = main.Student{id:0, age:18, name:&quot;jiajia&quot;, add:&quot;sz&quot;}
*p2 = main.Student{id:0, age:19, name:&quot;jiajia&quot;, add:&quot;gz&quot;}
*p3 = main.Student{id:3, age:20, name:&quot;jiajia&quot;, add:&quot;bj&quot;}
</code></pre>
<h2 id="colorred结构体作为函数参数传递"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">递</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{结构体作为函数参数传递}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">体</span><span class="mord cjk_fallback" style="color:red;">作</span><span class="mord cjk_fallback" style="color:red;">为</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">参</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">传</span><span class="mord cjk_fallback" style="color:red;">递</span></span></span></span></span></h2>
<h4 id="值传递">值传递</h4>
<pre><code class="language-/usr/bin/env">//Student 是一个结构体
type Student struct {
	id   int
	age  int
	name string
	add  string
}

func test(s1 Student) {
	s1.age = 20
	fmt.Println(&quot;test:s1.age = &quot;, s1.age)
}

func main() {
	s1 := Student{1, 18, &quot;jiajia&quot;, &quot;sz&quot;}
	test(s1)
	fmt.Println(&quot;main:s1.age = &quot;, s1.age)
}
</code></pre>
<p>输出结果：</p>
<pre><code>test:s1.age =  20
main:s1.age =  18
</code></pre>
<h4 id="地址传递">地址传递</h4>
<pre><code class="language-/usr/bin/env">type Student struct {
	id   int
	name string
}

func test(s1 *Student) {
	s1.id = 2
	fmt.Printf(&quot;test:%#v\n&quot;, *s1)
}

func main() {
	s1 := &amp;Student{1, &quot;jiajia&quot;}
	test(s1)
	fmt.Printf(&quot;main:%#v\n&quot;, *s1)
}
</code></pre>
<p>输出结果：</p>
<pre><code>test:main.Student{id:2, name:&quot;jiajia&quot;}
main:main.Student{id:2, name:&quot;jiajia&quot;}
</code></pre>
<h2 id="colorred结构体比较"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{结构体比较}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">体</span><span class="mord cjk_fallback" style="color:red;">比</span><span class="mord cjk_fallback" style="color:red;">较</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">//Student 是一个结构体
type Student struct {
	id   int
	age  int
	name string
	add  string
}

func main() {
	s1 := Student{1, 18, &quot;jiajia&quot;, &quot;sz&quot;}
	s2 := Student{1, 18, &quot;jiajia&quot;, &quot;sz&quot;}
	s3 := Student{3, 18, &quot;jiajia&quot;, &quot;sz&quot;}

	//比较
	fmt.Println(&quot;s1 == s2&quot;, s1 == s2) //s1 == s2 true
	fmt.Println(&quot;s1 == s3&quot;, s1 == s3) //s1 == s3 false

	//赋值
	var tmp Student
	tmp = s3
	fmt.Println(&quot;tmp = &quot;, tmp)          //tmp =  {3 18 jiajia sz}
	fmt.Println(&quot;tmp == s3&quot;, tmp == s3) //tmp == s3 true
}
</code></pre>
<h2 id="colorred结构体内存布局"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">布</mi><mi mathvariant="normal">局</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{结构体内存布局}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">体</span><span class="mord cjk_fallback" style="color:red;">内</span><span class="mord cjk_fallback" style="color:red;">存</span><span class="mord cjk_fallback" style="color:red;">布</span><span class="mord cjk_fallback" style="color:red;">局</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">type test struct {
	a int8
	b int8
	c int8
	d int8
}

func main() {
	n := test{
		1, 2, 3, 4,
	}
	fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)
	fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)
	fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)
	fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)
}
</code></pre>
<p>输出结果：</p>
<pre><code>n.a 0xc000054058
n.b 0xc000054059
n.c 0xc00005405a
n.d 0xc00005405b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之函数]]></title>
        <id>https://jiajia775.github.io/post/hanshu</id>
        <link href="https://jiajia775.github.io/post/hanshu">
        </link>
        <updated>2019-09-03T07:12:19.000Z</updated>
        <summary type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。</p>
]]></summary>
        <content type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。</p>
<!-- more -->
<h2 id="colorred函数的定义与调用"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{函数的定义与调用}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">与</span><span class="mord cjk_fallback" style="color:red;">调</span><span class="mord cjk_fallback" style="color:red;">用</span></span></span></span></span></h2>
<p>Go语言的函数定义使用func关键字定义<br>
具体格式如下：</p>
<pre><code>func 函数名(函数参数)函数返回值{
	函数体
}
</code></pre>
<pre><code class="language-/usr/bin/env">定义一个简单的两数相加的函数：
package main

import &quot;fmt&quot;

func calc(a, b int) int {
	return a + b
}

func main() {
	result := cala(1, 2)
	fmt.Println(result) //3
}
</code></pre>
<p>Go语言推荐写法如下：<br>
即给函数返回值命名</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc(a, b int) (result int) {
	result = a + b
	return
}

func main() {
	result := cala(1, 2)
	fmt.Println(result) //3
}
</code></pre>
<p>函数的参数和返回值都是可选的，可以实现一个既不需要参数也没有返回值的函数：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	fmt.Println(&quot;jiajia&quot;)
}

func main() {
	cala()
}
</code></pre>
<h2 id="colorred参数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{参数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">参</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<h4 id="可变参数">可变参数</h4>
<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识。<br>
注意：可变参数通常要作为函数的最后一个参数</p>
<pre><code class="language-/usr/bin/env">func calc(x ...int) (result int) {
	result = 0
	for _, v := range x {
		result = result + v
	}
	return
}
</code></pre>
<p>调用：</p>
<pre><code class="language-/usr/bin/env">func main() {
	result1:= calc()
	result2 := calc(10, 20)
	result3 := calc(10, 20, 30)
	fmt.Println(result1) //0
	fmt.Println(result2) //30
	fmt.Println(result3) //60
}
</code></pre>
<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>
<pre><code class="language-/usr/bin/env">func calc(x int, y ...int) (result int) {
	result = x
	for _, v := range y {
		result = result + v
	}
	return
}
</code></pre>
<p>调用：</p>
<pre><code class="language-/usr/bin/env">func main() {
	result1 := calc(10)
	result2 := calc(10, 20)
	result3 := calc(10, 20, 30)
	fmt.Println(result1) //10
	fmt.Println(result2) //30
	fmt.Println(result3) //60
}
</code></pre>
<h2 id="colorred变量作用域"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{变量作用域}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">作</span><span class="mord cjk_fallback" style="color:red;">用</span><span class="mord cjk_fallback" style="color:red;">域</span></span></span></span></span></h2>
<h4 id="全局变量">全局变量</h4>
<p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

var a string = &quot;jiajia&quot;

func calc() {
	fmt.Println(a) //&quot;jiajia&quot;
}

func main() {
	calc()
}
</code></pre>
<h4 id="局部变量">局部变量</h4>
<ul>
<li>函数内定义的变量无法在该函数外使用</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	//定义一个函数局部变量a,仅在该函数内生效
	var a int = 10
	fmt.Println(a)
}

func main() {
	calc()
	fmt.Println(a) //error,此时无法使用变量x
}
</code></pre>
<ul>
<li>语句块定义的变量</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
	fmt.Println(i)//此处无法使用变量i
}

func main() {
	calc()
}
</code></pre>
<p>注意：如果局部变量和全局变量重名，优先访问局部变量。</p>
<h2 id="colorred函数类型与变量"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{函数类型与变量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span><span class="mord cjk_fallback" style="color:red;">与</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">量</span></span></span></span></span></h2>
<h4 id="定义函数类型">定义函数类型</h4>
<p>type Functype func(int, int) int<br>
其中，Functype是函数类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func Add(a, b int) int {
	return a + b
}

func Min(a, b int) int {
	return a - b
}

//函数也是一种数据类型，通过type可以给函数类型起名字
//FuncType就是这个函数类型所起的名字

type funcType func(int, int) int

func main() {
	add := Add(10, 20)
	fmt.Println(&quot;add = &quot;, add) //传统方式

	//声明函数类型的变量，变量名叫做fTest
	var fTest funcType
	fTest = Add                 //是变量名就可以赋值 也可以统一写成 var fTest FuncType = Add
	result01 := fTest(100, 200) //用result01来接收
	fmt.Println(&quot;result01 = &quot;, result01)

	fTest = Min
	result02 := fTest(200, 50)
	fmt.Println(&quot;result02 = &quot;, result02)
}
</code></pre>
<h2 id="colorred高阶函数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">高</mi><mi mathvariant="normal">阶</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{高阶函数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">高</span><span class="mord cjk_fallback" style="color:red;">阶</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<h4 id="函数作为参数回调函数">函数作为参数(回调函数)</h4>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func Add(a, b int) int {
	return a + b
}

// Functype
type Functype func(int, int) int

//函数中有一个参数是函数类型，这个函数就是回调函数
//多态，多种形态，也就是说调用同一个接口，可以实现不同的表现，
func calc(a, b int, op Functype) int { //op相当于变量名可以写成：op func(int,int)int
	return op(a, b)
}

func main() {
	result := calc(10, 20, Add)
	fmt.Println(result)
}
</code></pre>
<h2 id="colorred匿名函数和闭包"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">匿</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">闭</mi><mi mathvariant="normal">包</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{匿名函数和闭包}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">匿</span><span class="mord cjk_fallback" style="color:red;">名</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">闭</span><span class="mord cjk_fallback" style="color:red;">包</span></span></span></span></span></h2>
<h4 id="匿名函数">匿名函数</h4>
<p>匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>
<pre><code class="language-/usr/bin/env">func(参数)(返回值){
    函数体
}
</code></pre>
<p>匿名函数多用于实现回调函数和闭包。<br>
示例：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func main() {
	a := 10
	str := &quot;jiajia&quot;
	//匿名函数，函数没有名字，
	//1.0
	f1 := func() {
		fmt.Println(&quot;a = &quot;, a)
		fmt.Println(&quot;str = &quot;, str)
	}
	f1() //函数调用

	//2.0
	func() {
		fmt.Println(&quot;a = &quot;, a)
		fmt.Println(&quot;str = &quot;, str)
	}() //可以并不需要参数接收，自己直接调用

	//3.0
	type FuncType func()
	var f3 FuncType //声明变量赋值
	f3 = f1
	f3()

	//4.0有参无返回值的匿名函数
	func(a, b int) {
		fmt.Printf(&quot;a = %d,str = %d\n&quot;, a, b)
	}(100, 200)

	//5.0有参有返回值的匿名函数
	result := func(a, b int) (result int) {
		result = a + b
		return
	}(3, 4)
	fmt.Println(&quot;result = &quot;, result)
	//等同于下面的写法
	var result2 int
	result2 = func(a, b int) (result2 int) {
		result2 = a + b
		return
	}(3, 4)
	fmt.Println(&quot;result2 = &quot;, result2)
}
</code></pre>
<h4 id="闭包">闭包</h4>
<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境，它不关心这些捕获了的变量和常量是否超出作用域，只要闭包还在使用它，这些变量都是会存在的<br>
简单例子：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func main() {
	a := 10
	str := &quot;java&quot;

	func() {
		a = 6
		str = &quot;go&quot;
		fmt.Printf(&quot;内部:a = %d,str = %s\n&quot;, a, str) //内部:a = 6,str = go
	}()
	fmt.Printf(&quot;外部:a = %d,str = %s\n&quot;, a, str) //外部:a = 6,str = go
}
</code></pre>
<p>复杂例子：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

//函数的返回值是一个匿名函数，返回一个函数类型
func MyFunc02() func() int {
	var x int

	return func() int {
		x++
		return x * x
	}

}

func MyFunc01() int {
	//函数被调用的时候才开始分配空间。才初始化为0

	var x int //没有初始化，值为0
	x++
	return x * x //函数调用完毕，x自动释放
}

func main() {
	//1.0
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1

	//2.0
	//因为返回的是一个函数类型，需要一个变量来接收。通过f来调用返回的匿名函数，f来调用闭包
	//他不关心这些捕获了的变量或者常量是否超出作用域
	//只要闭包还在使用它，这些变量就会存在
	f := MyFunc02()
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
}
</code></pre>
<h2 id="colorreddefer语句"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">语</mi><mi mathvariant="normal">句</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{defer语句}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">d</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord cjk_fallback" style="color:red;">语</span><span class="mord cjk_fallback" style="color:red;">句</span></span></span></span></span></h2>
<p>Go语言中的defer语句会将其后面跟随的语句进行延迟处理。</p>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(&quot;start&quot;)
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println(&quot;end&quot;)
}
</code></pre>
<p>输出结果：</p>
<pre><code>start
end
3
2
1
</code></pre>
<p>由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。<br>
defer案例题：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(&quot;-----------------&quot;)
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2				//3----&gt;4
	defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))
	a = 0				//2----&gt;2
	defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))
	b = 1
}
</code></pre>
<p>输出结果：</p>
<pre><code>----------
10 1 2 3
-----------------
20 0 2 2
-----------------
2 0 2 2
-----------------
1 1 3 4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之map]]></title>
        <id>https://jiajia775.github.io/post/map</id>
        <link href="https://jiajia775.github.io/post/map">
        </link>
        <updated>2019-09-03T01:47:52.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言map的基本使用<br>
Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言map的基本使用<br>
Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。</p>
<!-- more --> 
<h2 id="colorredmap"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span></span></span></span></span></h2>
<p>map是一种无序的基于key-value的数据结构<br>
Go语言中的map是引用类型，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{必须}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span></span></span></span></span>初始化才能使用。</p>
<h2 id="colorredmap的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h2>
<p>语法为：<code>map[KeyType]ValueType</code></p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：<br>
<code>make(map[KeyType]ValueType, [cap])</code><br>
cap表示map的容量，该参数不是必须的，但是初始化的时候应该指定一个合理的容量。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var a map[string]int
	a = make(map[string]int)
	a[&quot;jiajia&quot;] = 100
	fmt.Println(a) //map[jiajia:100]

	b := make(map[string]int)
	b[&quot;Go&quot;] = 100
	fmt.Println(b) //map[Go:100]
}
</code></pre>
<p>map也支持在声明的时候填充元素，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	fmt.Println(a) //map[Go:2 jiajia:1]
}
</code></pre>
<h2 id="colorred判断某个键是否存在"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{判断某个键是否存在}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">判</span><span class="mord cjk_fallback" style="color:red;">断</span><span class="mord cjk_fallback" style="color:red;">某</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">否</span><span class="mord cjk_fallback" style="color:red;">存</span><span class="mord cjk_fallback" style="color:red;">在</span></span></span></span></span></h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:<br>
<code>value, ok := map[key]</code><br>
示例代码：</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	v, ok := a[&quot;jiajia&quot;]
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(&quot;None&quot;)
	}
}
</code></pre>
<h2 id="colorredmap的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	for v, k := range a {
		fmt.Println(k, v)
	}
}
</code></pre>
<p>注意：遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="colorred使用delete函数删除键值对"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">对</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{使用delete函数删除键值对}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">使</span><span class="mord cjk_fallback" style="color:red;">用</span><span class="mord mathdefault" style="color:red;">d</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">删</span><span class="mord cjk_fallback" style="color:red;">除</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">对</span></span></span></span></span></h2>
<p>格式：<br>
<code>delete(map, key)</code></p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	delete(a, &quot;jiajia&quot;) //删除操作
	for v, k := range a {
		fmt.Println(k, v)
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之指针]]></title>
        <id>https://jiajia775.github.io/post/zhizheng</id>
        <link href="https://jiajia775.github.io/post/zhizheng">
        </link>
        <updated>2019-09-03T00:34:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言指针的基本使用<br>
Go语言中的指针不能进行偏移和运算，是安全指针。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言指针的基本使用<br>
Go语言中的指针不能进行偏移和运算，是安全指针。</p>
 <!-- more -->
<h2 id="colorred指针地址和指针类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">指</mi><mi mathvariant="normal">针</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">针</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{指针地址和指针类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">针</span><span class="mord cjk_fallback" style="color:red;">地</span><span class="mord cjk_fallback" style="color:red;">址</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">针</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<br>
使用 &amp; 字符放在变量前面对变量进行“取地址”操作。<br>
语法如下：<br>
<code>ptr := &amp;v</code></p>
<ul>
<li>v代表被取地址的变量</li>
<li>ptr用户被接收地址的变量，ptr的类型为 *T，称作指针类型，*代表指针<br>
例子：</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	//每个变量都有两层含义：变量的内存，变量的地址
	var a int
	fmt.Println(&quot;a = &quot;, a)   //变量的内存a =  0
	fmt.Println(&quot;&amp;a = &quot;, &amp;a) //变量的地址&amp;a =  0xc00004e058

	var p *int //定义一个变量p，类型为*int
	p = &amp;a     //a的地址赋值给p
	fmt.Printf(&quot;p = %v, &amp;a = %v\n&quot;, p, &amp;a) //p = 0xc00004e058, &amp;a = 0xc00004e058

	*p = 666 //*p操作的不是p的内存,而是p所指向的内存(就是a)
	fmt.Printf(&quot;*p = %v,a = %v&quot;, *p, a) //*p = 666,a = 666
}
</code></pre>
<p><img src="https://jiajia775.github.io/post-images/1567472710306.png" alt=""><br>
总结：<br>
&amp;取出地址，* 根据地址取出地址指向的值，取地址操作符&amp;和取值操作符* 是一对互补操作符。</p>
<h4 id="指针传值示例">指针传值示例：</h4>
<pre><code class="language-/usr/bin/env">func modify1(x int) {
	x = 100
}
func modify2(x *int) {
	*x = 100
}
func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10
	modify2(&amp;a)
	fmt.Println(a) // 100
}
</code></pre>
<h4 id="不要操作没有合法指向的内存">不要操作没有合法指向的内存</h4>
<pre><code class="language-/usr/bin/env">func main() {
	var p *int
	fmt.Println(p) //nil

	*p = 666 //error,没有合法指向，不能赋值
	fmt.Println(*p) //error
}
</code></pre>
<ul>
<li>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</li>
<li>对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。</li>
</ul>
<h2 id="colorrednew函数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{new函数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.02691em;color:red;">w</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<p>Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
<h4 id="new">new</h4>
<p>使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p>
<pre><code class="language-/usr/bin/env"> func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf(&quot;%T\n&quot;, a) // *int
	fmt.Printf(&quot;%T\n&quot;, b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
</code></pre>
<p>上面没有合法指向的解决办法：</p>
<pre><code class="language-/usr/bin/env">func main() {
	var p1 *int
	p1 = new(int)
	*p1 = 666
	fmt.Println(*p1) //666

	p2 := new(int)
	*p2 = 777
	fmt.Println(*p2) //777
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之切片]]></title>
        <id>https://jiajia775.github.io/post/Slice</id>
        <link href="https://jiajia775.github.io/post/Slice">
        </link>
        <updated>2019-09-02T12:58:14.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
<!-- more -->
<h2 id="colorred切片slice"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mo>(</mo><mi>S</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片(Slice)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mopen" style="color:red;">(</span><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">e</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。<br>
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>
<h2 id="colorred切片的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h2>
<p><code>var 变量名 []切片类型</code></p>
<pre><code class="language-/usr/bin/env">func main() {
	var a []int
	var b = []int{}
	fmt.Println(a == nil)
	fmt.Println(b == nil)

	var c = []bool{false, true}
	var d = []bool{false, true}
	fmt.Println(c == d)
}
</code></pre>
<h2 id="colorred切片的长度和容量"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的长度和容量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">量</span></span></span></span></span></h2>
<ol>
<li>切片拥有自己的长度和容量</li>
<li>可以通过使用内置的len()函数求长度</li>
<li>使用内置的cap()函数求切片的容量。</li>
</ol>
<h2 id="colorred基于数组定义的切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">基</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{基于数组定义的切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">基</span><span class="mord cjk_fallback" style="color:red;">于</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<p>其使用方法类似python的切片</p>
<pre><code class="language-/usr/bin/env"> func main() {
	// 基于数组定义切片
	a := [5]int{55, 56, 57, 58, 59}
	b := a[1:4]                     //基于数组a创建切片，包括元素a[1],a[2],a[3]
	fmt.Println(b)                  //[56 57 58]
	fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:[]int
}
</code></pre>
<h2 id="colorred切片再切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片再切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">再</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	//切片再切片
	a := [...]string{&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;n3&quot;, &quot;n4&quot;, &quot;n5&quot;}
	fmt.Printf(&quot;a:%v type:%T len:%d  cap:%d\n&quot;, a, a, len(a), cap(a))
	b := a[1:3]
	fmt.Printf(&quot;b:%v type:%T len:%d  cap:%d\n&quot;, b, b, len(b), cap(b))
	c := b[1:5]
	fmt.Printf(&quot;c:%v type:%T len:%d  cap:%d\n&quot;, c, c, len(c), cap(c))
}
</code></pre>
<p>输出：</p>
<pre><code class="language-/usr/bin/env">a:[n0 n1 n2 n3 n4 n5] type:[6]string len:6  cap:6
b:[n1 n2] type:[]string len:2  cap:5
c:[n2 n3 n4 n5] type:[]string len:4  cap:4
</code></pre>
<h3 id="注意-对切片进行再切片时索引不能超过原数组的长度否则会出现索引越界的错误">注意： 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</h3>
<h2 id="colorredmake函数构造切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">造</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{make函数构造切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03148em;color:red;">k</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">造</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>
<h2 id="colorred切片的本质"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">质</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的本质}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">本</span><span class="mord cjk_fallback" style="color:red;">质</span></span></span></span></span></h2>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<p>举个例子，有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。<br>
<img src="https://jiajia775.github.io/post-images/1567430493603.png" alt=""><br>
切片s2 := a[3:6]，相应示意图如下：<br>
<img src="https://jiajia775.github.io/post-images/1567430512393.png" alt=""></p>
<h2 id="colorred切片不能直接比较"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片不能直接比较}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">直</span><span class="mord cjk_fallback" style="color:red;">接</span><span class="mord cjk_fallback" style="color:red;">比</span><span class="mord cjk_fallback" style="color:red;">较</span></span></span></span></span></h2>
<ol>
<li>切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。</li>
<li>切片唯一合法的比较操作是和nil比较。</li>
<li>重要：判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断</li>
</ol>
<pre><code class="language-/usr/bin/env">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>
<h2 id="colorred切片拷贝赋值"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">拷</mi><mi mathvariant="normal">贝</mi><mi mathvariant="normal">赋</mi><mi mathvariant="normal">值</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片拷贝赋值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">拷</span><span class="mord cjk_fallback" style="color:red;">贝</span><span class="mord cjk_fallback" style="color:red;">赋</span><span class="mord cjk_fallback" style="color:red;">值</span></span></span></span></span></h2>
<p>注意：切片是引用类型，切片拷贝前后，两个变量共享底层数组</p>
<pre><code class="language-/usr/bin/env">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>
<p>copy方法：</p>
<pre><code class="language-/usr/bin/env">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>
<h2 id="colorred切片append方法扩容特点"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">扩</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">点</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片append方法扩容特点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">d</span><span class="mord cjk_fallback" style="color:red;">方</span><span class="mord cjk_fallback" style="color:red;">法</span><span class="mord cjk_fallback" style="color:red;">扩</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">特</span><span class="mord cjk_fallback" style="color:red;">点</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var a = make([]int, 0, 1)
	oldCaps := cap(a)
	for i := 0; i &lt; 30; i++ {
		a = append(a, i)
		if newCaps := cap(a); oldCaps &lt; newCaps {
			fmt.Printf(&quot;cap:%d======&gt;%d\n&quot;, oldCaps, newCaps)
			oldCaps = newCaps
		}
	}
}
</code></pre>
<p>输出：</p>
<pre><code>cap:1======&gt;2
cap:2======&gt;4
cap:4======&gt;8
cap:8======&gt;16
cap:16======&gt;32
</code></pre>
<h2 id="colorred切片删除元素"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片删除元素}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">删</span><span class="mord cjk_fallback" style="color:red;">除</span><span class="mord cjk_fallback" style="color:red;">元</span><span class="mord cjk_fallback" style="color:red;">素</span></span></span></span></span></h2>
<p>Go语言中并没有删除切片元素的专用方法，可以使用切片本身的特性来删除元素</p>
<pre><code class="language-/usr/bin/env">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之数组]]></title>
        <id>https://jiajia775.github.io/post/shuzu</id>
        <link href="https://jiajia775.github.io/post/shuzu">
        </link>
        <updated>2019-09-02T07:03:10.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言数组的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言数组的基本使用</p>
<!-- more -->
<h2 id="colorredarray数组定义"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></strong></h2>
<p>数组是同一种数据类型元素的集合。<br>
数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>
数组基本语法：<br>
<code>var 数组变量名 [元素数量]类型</code></p>
<pre><code class="language-/usr/bin/env">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mo>:</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">。</mi><mo>[</mo><mn>5</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">和</mi><mo>[</mo><mn>10</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{注意:数组的长度必须是常量，一旦定义，长度不能改变。[5]int和[10]int是不同类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">注</span><span class="mord cjk_fallback" style="color:red;">意</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">一</span><span class="mord cjk_fallback" style="color:red;">旦</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">改</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">。</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">5</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">1</span><span class="mord" style="color:red;">0</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></p>
<h2 id="colorredarray数组初始化"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">初</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">化</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)初始化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">初</span><span class="mord cjk_fallback" style="color:red;">始</span><span class="mord cjk_fallback" style="color:red;">化</span></span></span></span></span></h2>
<ul>
<li>初始化数组时可以使用初始化列表来设置数组元素的值。</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>短声明</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	x := [3]int{1, 2, 3}
	fmt.Println(x)
}
</code></pre>
<ul>
<li>让编译器根据初始值的个数自行推断数组的长度</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                          //数组会初始化为int类型的零值
	var numArray = [...]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                        //[0 0 0]
	fmt.Println(numArray)                         //[1 2 0]
	fmt.Println(cityArray)                        //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>使用指定索引值的方式来初始化数组</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{1: &quot;北京&quot;, 3: &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	fmt.Println(cityArray)                              //[ 北京  上海 深圳]
	fmt.Printf(&quot;type is %T&quot;, cityArray)                 //type is [5]string
}
</code></pre>
<h2 id="colorredarray数组遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	//for遍历
	for i := 0; i &lt; len(cityArray); i++ {
		fmt.Println(cityArray[i])
	}
	//for range遍历
	for i, data := range cityArray {
		fmt.Println(i, data)
	}
}
</code></pre>
<h2 id="colorred多维数组"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">多</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{多维数组}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">多</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span></span></span></span></span></h2>
<p>以二维数组为例</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[1][1]) //支持索引取值:深圳
}
</code></pre>
<h2 id="colorred二维数组的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{二维数组的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">二</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>
<p>输出：</p>
<pre><code>北京	上海	
广州	深圳	
成都	重庆
</code></pre>
<p>注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：</p>
<pre><code class="language-/usr/bin/env">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>
<h2 id="colorred数组是值类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{数组是值类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var x = [3]int{1, 2, 3}
	fmt.Println(x)
	f1(x)
	fmt.Println(x)
}

func f1(a [3]int) {
	a[0] = 100      //改变第一个值
}
</code></pre>
<p>输出：</p>
<pre><code>[1 2 3]
[1 2 3]
</code></pre>
]]></content>
    </entry>
</feed>