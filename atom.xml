<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiajiaba.github.io</id>
    <title>JIAJIA</title>
    <updated>2019-09-03T13:02:21.403Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiajiaba.github.io"/>
    <link rel="self" href="https://jiajiaba.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiajiaba.github.io/images/avatar.png</logo>
    <icon>https://jiajiaba.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, JIAJIA</rights>
    <entry>
        <title type="html"><![CDATA[Go语言基础之函数]]></title>
        <id>https://jiajiaba.github.io/post/hanshu</id>
        <link href="https://jiajiaba.github.io/post/hanshu">
        </link>
        <updated>2019-09-03T07:12:19.000Z</updated>
        <summary type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。</p>
]]></summary>
        <content type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。</p>
<!-- more -->
<h2 id="colorred函数的定义与调用"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{函数的定义与调用}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">与</span><span class="mord cjk_fallback" style="color:red;">调</span><span class="mord cjk_fallback" style="color:red;">用</span></span></span></span></span></h2>
<p>Go语言的函数定义使用func关键字定义<br>
具体格式如下：</p>
<pre><code>func 函数名(函数参数)函数返回值{
	函数体
}
</code></pre>
<pre><code class="language-/usr/bin/env">定义一个简单的两数相加的函数：
package main

import &quot;fmt&quot;

func calc(a, b int) int {
	return a + b
}

func main() {
	result := cala(1, 2)
	fmt.Println(result) //3
}
</code></pre>
<p>Go语言推荐写法如下：<br>
即给函数返回值命名</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc(a, b int) (result int) {
	result = a + b
	return
}

func main() {
	result := cala(1, 2)
	fmt.Println(result) //3
}
</code></pre>
<p>函数的参数和返回值都是可选的，可以实现一个既不需要参数也没有返回值的函数：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	fmt.Println(&quot;jiajia&quot;)
}

func main() {
	cala()
}
</code></pre>
<h2 id="colorred参数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{参数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">参</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<h4 id="可变参数">可变参数</h4>
<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识。<br>
注意：可变参数通常要作为函数的最后一个参数</p>
<pre><code class="language-/usr/bin/env">func calc(x ...int) (result int) {
	result = 0
	for _, v := range x {
		result = result + v
	}
	return
}
</code></pre>
<p>调用：</p>
<pre><code class="language-/usr/bin/env">func main() {
	result1:= calc()
	result2 := calc(10, 20)
	result3 := calc(10, 20, 30)
	fmt.Println(result1) //0
	fmt.Println(result2) //30
	fmt.Println(result3) //60
}
</code></pre>
<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>
<pre><code class="language-/usr/bin/env">func calc(x int, y ...int) (result int) {
	result = x
	for _, v := range y {
		result = result + v
	}
	return
}
</code></pre>
<p>调用：</p>
<pre><code class="language-/usr/bin/env">func main() {
	result1 := calc(10)
	result2 := calc(10, 20)
	result3 := calc(10, 20, 30)
	fmt.Println(result1) //10
	fmt.Println(result2) //30
	fmt.Println(result3) //60
}
</code></pre>
<h2 id="colorred变量作用域"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{变量作用域}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">作</span><span class="mord cjk_fallback" style="color:red;">用</span><span class="mord cjk_fallback" style="color:red;">域</span></span></span></span></span></h2>
<h4 id="全局变量">全局变量</h4>
<p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

var a string = &quot;jiajia&quot;

func calc() {
	fmt.Println(a) //&quot;jiajia&quot;
}

func main() {
	calc()
}
</code></pre>
<h4 id="局部变量">局部变量</h4>
<ul>
<li>函数内定义的变量无法在该函数外使用</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	//定义一个函数局部变量a,仅在该函数内生效
	var a int = 10
	fmt.Println(a)
}

func main() {
	calc()
	fmt.Println(a) //error,此时无法使用变量x
}
</code></pre>
<ul>
<li>语句块定义的变量</li>
</ul>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
	fmt.Println(i)//此处无法使用变量i
}

func main() {
	calc()
}
</code></pre>
<p>注意：如果局部变量和全局变量重名，优先访问局部变量。</p>
<h2 id="colorred函数类型与变量"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{函数类型与变量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span><span class="mord cjk_fallback" style="color:red;">与</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">量</span></span></span></span></span></h2>
<h4 id="定义函数类型">定义函数类型</h4>
<p>type Functype func(int, int) int<br>
其中，Functype是函数类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func Add(a, b int) int {
	return a + b
}

func Min(a, b int) int {
	return a - b
}

//函数也是一种数据类型，通过type可以给函数类型起名字
//FuncType就是这个函数类型所起的名字

type funcType func(int, int) int

func main() {
	add := Add(10, 20)
	fmt.Println(&quot;add = &quot;, add) //传统方式

	//声明函数类型的变量，变量名叫做fTest
	var fTest funcType
	fTest = Add                 //是变量名就可以赋值 也可以统一写成 var fTest FuncType = Add
	result01 := fTest(100, 200) //用result01来接收
	fmt.Println(&quot;result01 = &quot;, result01)

	fTest = Min
	result02 := fTest(200, 50)
	fmt.Println(&quot;result02 = &quot;, result02)
}
</code></pre>
<h2 id="colorred高阶函数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">高</mi><mi mathvariant="normal">阶</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{高阶函数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">高</span><span class="mord cjk_fallback" style="color:red;">阶</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<h4 id="函数作为参数回调函数">函数作为参数(回调函数)</h4>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func Add(a, b int) int {
	return a + b
}

// Functype
type Functype func(int, int) int

//函数中有一个参数是函数类型，这个函数就是回调函数
//多态，多种形态，也就是说调用同一个接口，可以实现不同的表现，
func calc(a, b int, op Functype) int { //op相当于变量名可以写成：op func(int,int)int
	return op(a, b)
}

func main() {
	result := calc(10, 20, Add)
	fmt.Println(result)
}
</code></pre>
<h2 id="colorred匿名函数和闭包"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">匿</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">闭</mi><mi mathvariant="normal">包</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{匿名函数和闭包}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">匿</span><span class="mord cjk_fallback" style="color:red;">名</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">闭</span><span class="mord cjk_fallback" style="color:red;">包</span></span></span></span></span></h2>
<h4 id="匿名函数">匿名函数</h4>
<p>匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>
<pre><code class="language-/usr/bin/env">func(参数)(返回值){
    函数体
}
</code></pre>
<p>匿名函数多用于实现回调函数和闭包。<br>
示例：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func main() {
	a := 10
	str := &quot;jiajia&quot;
	//匿名函数，函数没有名字，
	//1.0
	f1 := func() {
		fmt.Println(&quot;a = &quot;, a)
		fmt.Println(&quot;str = &quot;, str)
	}
	f1() //函数调用

	//2.0
	func() {
		fmt.Println(&quot;a = &quot;, a)
		fmt.Println(&quot;str = &quot;, str)
	}() //可以并不需要参数接收，自己直接调用

	//3.0
	type FuncType func()
	var f3 FuncType //声明变量赋值
	f3 = f1
	f3()

	//4.0有参无返回值的匿名函数
	func(a, b int) {
		fmt.Printf(&quot;a = %d,str = %d\n&quot;, a, b)
	}(100, 200)

	//5.0有参有返回值的匿名函数
	result := func(a, b int) (result int) {
		result = a + b
		return
	}(3, 4)
	fmt.Println(&quot;result = &quot;, result)
	//等同于下面的写法
	var result2 int
	result2 = func(a, b int) (result2 int) {
		result2 = a + b
		return
	}(3, 4)
	fmt.Println(&quot;result2 = &quot;, result2)
}
</code></pre>
<h4 id="闭包">闭包</h4>
<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境，它不关心这些捕获了的变量和常量是否超出作用域，只要闭包还在使用它，这些变量都是会存在的<br>
简单例子：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func main() {
	a := 10
	str := &quot;java&quot;

	func() {
		a = 6
		str = &quot;go&quot;
		fmt.Printf(&quot;内部:a = %d,str = %s\n&quot;, a, str) //内部:a = 6,str = go
	}()
	fmt.Printf(&quot;外部:a = %d,str = %s\n&quot;, a, str) //外部:a = 6,str = go
}
</code></pre>
<p>复杂例子：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

//函数的返回值是一个匿名函数，返回一个函数类型
func MyFunc02() func() int {
	var x int

	return func() int {
		x++
		return x * x
	}

}

func MyFunc01() int {
	//函数被调用的时候才开始分配空间。才初始化为0

	var x int //没有初始化，值为0
	x++
	return x * x //函数调用完毕，x自动释放
}

func main() {
	//1.0
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1
	fmt.Println(MyFunc01()) //1

	//2.0
	//因为返回的是一个函数类型，需要一个变量来接收。通过f来调用返回的匿名函数，f来调用闭包
	//他不关心这些捕获了的变量或者常量是否超出作用域
	//只要闭包还在使用它，这些变量就会存在
	f := MyFunc02()
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
}
</code></pre>
<h2 id="colorreddefer语句"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">语</mi><mi mathvariant="normal">句</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{defer语句}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">d</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord cjk_fallback" style="color:red;">语</span><span class="mord cjk_fallback" style="color:red;">句</span></span></span></span></span></h2>
<p>Go语言中的defer语句会将其后面跟随的语句进行延迟处理。</p>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(&quot;start&quot;)
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println(&quot;end&quot;)
}
</code></pre>
<p>输出结果：</p>
<pre><code>start
end
3
2
1
</code></pre>
<p>由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。<br>
defer案例题：</p>
<pre><code class="language-/usr/bin/env">package main

import &quot;fmt&quot;

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(&quot;-----------------&quot;)
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2				//3----&gt;4
	defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))
	a = 0				//2----&gt;2
	defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))
	b = 1
}
</code></pre>
<p>输出结果：</p>
<pre><code>----------
10 1 2 3
-----------------
20 0 2 2
-----------------
2 0 2 2
-----------------
1 1 3 4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之map]]></title>
        <id>https://jiajiaba.github.io/post/map</id>
        <link href="https://jiajiaba.github.io/post/map">
        </link>
        <updated>2019-09-03T01:47:52.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言map的基本使用<br>
Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言map的基本使用<br>
Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。</p>
<!-- more --> 
<h2 id="colorredmap"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span></span></span></span></span></h2>
<p>map是一种无序的基于key-value的数据结构<br>
Go语言中的map是引用类型，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{必须}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span></span></span></span></span>初始化才能使用。</p>
<h2 id="colorredmap的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h2>
<p>语法为：<code>map[KeyType]ValueType</code></p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：<br>
<code>make(map[KeyType]ValueType, [cap])</code><br>
cap表示map的容量，该参数不是必须的，但是初始化的时候应该指定一个合理的容量。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var a map[string]int
	a = make(map[string]int)
	a[&quot;jiajia&quot;] = 100
	fmt.Println(a) //map[jiajia:100]

	b := make(map[string]int)
	b[&quot;Go&quot;] = 100
	fmt.Println(b) //map[Go:100]
}
</code></pre>
<p>map也支持在声明的时候填充元素，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	fmt.Println(a) //map[Go:2 jiajia:1]
}
</code></pre>
<h2 id="colorred判断某个键是否存在"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{判断某个键是否存在}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">判</span><span class="mord cjk_fallback" style="color:red;">断</span><span class="mord cjk_fallback" style="color:red;">某</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">否</span><span class="mord cjk_fallback" style="color:red;">存</span><span class="mord cjk_fallback" style="color:red;">在</span></span></span></span></span></h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:<br>
<code>value, ok := map[key]</code><br>
示例代码：</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	v, ok := a[&quot;jiajia&quot;]
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(&quot;None&quot;)
	}
}
</code></pre>
<h2 id="colorredmap的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{map的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	for v, k := range a {
		fmt.Println(k, v)
	}
}
</code></pre>
<p>注意：遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="colorred使用delete函数删除键值对"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">对</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{使用delete函数删除键值对}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">使</span><span class="mord cjk_fallback" style="color:red;">用</span><span class="mord mathdefault" style="color:red;">d</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">删</span><span class="mord cjk_fallback" style="color:red;">除</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">对</span></span></span></span></span></h2>
<p>格式：<br>
<code>delete(map, key)</code></p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	a := map[string]int{
		&quot;jiajia&quot;: 1,
		&quot;Go&quot;:     2,
	}
	delete(a, &quot;jiajia&quot;) //删除操作
	for v, k := range a {
		fmt.Println(k, v)
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之指针]]></title>
        <id>https://jiajiaba.github.io/post/zhizheng</id>
        <link href="https://jiajiaba.github.io/post/zhizheng">
        </link>
        <updated>2019-09-03T00:34:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言指针的基本使用<br>
Go语言中的指针不能进行偏移和运算，是安全指针。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言指针的基本使用<br>
Go语言中的指针不能进行偏移和运算，是安全指针。</p>
 <!-- more -->
<h2 id="colorred指针地址和指针类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">指</mi><mi mathvariant="normal">针</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">针</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{指针地址和指针类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">针</span><span class="mord cjk_fallback" style="color:red;">地</span><span class="mord cjk_fallback" style="color:red;">址</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">针</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<br>
使用 &amp; 字符放在变量前面对变量进行“取地址”操作。<br>
语法如下：<br>
<code>ptr := &amp;v</code></p>
<ul>
<li>v代表被取地址的变量</li>
<li>ptr用户被接收地址的变量，ptr的类型为 *T，称作指针类型，*代表指针<br>
例子：</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	//每个变量都有两层含义：变量的内存，变量的地址
	var a int
	fmt.Println(&quot;a = &quot;, a)   //变量的内存a =  0
	fmt.Println(&quot;&amp;a = &quot;, &amp;a) //变量的地址&amp;a =  0xc00004e058

	var p *int //定义一个变量p，类型为*int
	p = &amp;a     //a的地址赋值给p
	fmt.Printf(&quot;p = %v, &amp;a = %v\n&quot;, p, &amp;a) //p = 0xc00004e058, &amp;a = 0xc00004e058

	*p = 666 //*p操作的不是p的内存,而是p所指向的内存(就是a)
	fmt.Printf(&quot;*p = %v,a = %v&quot;, *p, a) //*p = 666,a = 666
}
</code></pre>
<p><img src="https://jiajiaba.github.io/post-images/1567472710306.png" alt=""><br>
总结：<br>
&amp;取出地址，* 根据地址取出地址指向的值，取地址操作符&amp;和取值操作符* 是一对互补操作符。</p>
<h4 id="指针传值示例">指针传值示例：</h4>
<pre><code class="language-/usr/bin/env">func modify1(x int) {
	x = 100
}
func modify2(x *int) {
	*x = 100
}
func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10
	modify2(&amp;a)
	fmt.Println(a) // 100
}
</code></pre>
<h4 id="不要操作没有合法指向的内存">不要操作没有合法指向的内存</h4>
<pre><code class="language-/usr/bin/env">func main() {
	var p *int
	fmt.Println(p) //nil

	*p = 666 //error,没有合法指向，不能赋值
	fmt.Println(*p) //error
}
</code></pre>
<ul>
<li>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</li>
<li>对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。</li>
</ul>
<h2 id="colorrednew函数"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{new函数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.02691em;color:red;">w</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span></span></span></span></span></h2>
<p>Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
<h4 id="new">new</h4>
<p>使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p>
<pre><code class="language-/usr/bin/env"> func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf(&quot;%T\n&quot;, a) // *int
	fmt.Printf(&quot;%T\n&quot;, b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
</code></pre>
<p>上面没有合法指向的解决办法：</p>
<pre><code class="language-/usr/bin/env">func main() {
	var p1 *int
	p1 = new(int)
	*p1 = 666
	fmt.Println(*p1) //666

	p2 := new(int)
	*p2 = 777
	fmt.Println(*p2) //777
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之切片]]></title>
        <id>https://jiajiaba.github.io/post/Slice</id>
        <link href="https://jiajiaba.github.io/post/Slice">
        </link>
        <updated>2019-09-02T12:58:14.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言切片的基本使用<br>
切片是由数组转变过来，因为数组有很多的局限性。</p>
<!-- more -->
<h2 id="colorred切片slice"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mo>(</mo><mi>S</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片(Slice)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mopen" style="color:red;">(</span><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">e</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。<br>
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>
<h2 id="colorred切片的定义"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></h2>
<p><code>var 变量名 []切片类型</code></p>
<pre><code class="language-/usr/bin/env">func main() {
	var a []int
	var b = []int{}
	fmt.Println(a == nil)
	fmt.Println(b == nil)

	var c = []bool{false, true}
	var d = []bool{false, true}
	fmt.Println(c == d)
}
</code></pre>
<h2 id="colorred切片的长度和容量"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的长度和容量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">量</span></span></span></span></span></h2>
<ol>
<li>切片拥有自己的长度和容量</li>
<li>可以通过使用内置的len()函数求长度</li>
<li>使用内置的cap()函数求切片的容量。</li>
</ol>
<h2 id="colorred基于数组定义的切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">基</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{基于数组定义的切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">基</span><span class="mord cjk_fallback" style="color:red;">于</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<p>其使用方法类似python的切片</p>
<pre><code class="language-/usr/bin/env"> func main() {
	// 基于数组定义切片
	a := [5]int{55, 56, 57, 58, 59}
	b := a[1:4]                     //基于数组a创建切片，包括元素a[1],a[2],a[3]
	fmt.Println(b)                  //[56 57 58]
	fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:[]int
}
</code></pre>
<h2 id="colorred切片再切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片再切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">再</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	//切片再切片
	a := [...]string{&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;n3&quot;, &quot;n4&quot;, &quot;n5&quot;}
	fmt.Printf(&quot;a:%v type:%T len:%d  cap:%d\n&quot;, a, a, len(a), cap(a))
	b := a[1:3]
	fmt.Printf(&quot;b:%v type:%T len:%d  cap:%d\n&quot;, b, b, len(b), cap(b))
	c := b[1:5]
	fmt.Printf(&quot;c:%v type:%T len:%d  cap:%d\n&quot;, c, c, len(c), cap(c))
}
</code></pre>
<p>输出：</p>
<pre><code class="language-/usr/bin/env">a:[n0 n1 n2 n3 n4 n5] type:[6]string len:6  cap:6
b:[n1 n2] type:[]string len:2  cap:5
c:[n2 n3 n4 n5] type:[]string len:4  cap:4
</code></pre>
<h3 id="注意-对切片进行再切片时索引不能超过原数组的长度否则会出现索引越界的错误">注意： 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</h3>
<h2 id="colorredmake函数构造切片"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">构</mi><mi mathvariant="normal">造</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{make函数构造切片}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">m</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03148em;color:red;">k</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mord cjk_fallback" style="color:red;">造</span><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>
<h2 id="colorred切片的本质"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">质</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片的本质}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">本</span><span class="mord cjk_fallback" style="color:red;">质</span></span></span></span></span></h2>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<p>举个例子，有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。<br>
<img src="https://jiajiaba.github.io/post-images/1567430493603.png" alt=""><br>
切片s2 := a[3:6]，相应示意图如下：<br>
<img src="https://jiajiaba.github.io/post-images/1567430512393.png" alt=""></p>
<h2 id="colorred切片不能直接比较"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片不能直接比较}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">直</span><span class="mord cjk_fallback" style="color:red;">接</span><span class="mord cjk_fallback" style="color:red;">比</span><span class="mord cjk_fallback" style="color:red;">较</span></span></span></span></span></h2>
<ol>
<li>切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。</li>
<li>切片唯一合法的比较操作是和nil比较。</li>
<li>重要：判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断</li>
</ol>
<pre><code class="language-/usr/bin/env">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>
<h2 id="colorred切片拷贝赋值"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">拷</mi><mi mathvariant="normal">贝</mi><mi mathvariant="normal">赋</mi><mi mathvariant="normal">值</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片拷贝赋值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">拷</span><span class="mord cjk_fallback" style="color:red;">贝</span><span class="mord cjk_fallback" style="color:red;">赋</span><span class="mord cjk_fallback" style="color:red;">值</span></span></span></span></span></h2>
<p>注意：切片是引用类型，切片拷贝前后，两个变量共享底层数组</p>
<pre><code class="language-/usr/bin/env">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>
<p>copy方法：</p>
<pre><code class="language-/usr/bin/env">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>
<h2 id="colorred切片append方法扩容特点"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">扩</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">点</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片append方法扩容特点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">p</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">d</span><span class="mord cjk_fallback" style="color:red;">方</span><span class="mord cjk_fallback" style="color:red;">法</span><span class="mord cjk_fallback" style="color:red;">扩</span><span class="mord cjk_fallback" style="color:red;">容</span><span class="mord cjk_fallback" style="color:red;">特</span><span class="mord cjk_fallback" style="color:red;">点</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var a = make([]int, 0, 1)
	oldCaps := cap(a)
	for i := 0; i &lt; 30; i++ {
		a = append(a, i)
		if newCaps := cap(a); oldCaps &lt; newCaps {
			fmt.Printf(&quot;cap:%d======&gt;%d\n&quot;, oldCaps, newCaps)
			oldCaps = newCaps
		}
	}
}
</code></pre>
<p>输出：</p>
<pre><code>cap:1======&gt;2
cap:2======&gt;4
cap:4======&gt;8
cap:8======&gt;16
cap:16======&gt;32
</code></pre>
<h2 id="colorred切片删除元素"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">切</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{切片删除元素}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">切</span><span class="mord cjk_fallback" style="color:red;">片</span><span class="mord cjk_fallback" style="color:red;">删</span><span class="mord cjk_fallback" style="color:red;">除</span><span class="mord cjk_fallback" style="color:red;">元</span><span class="mord cjk_fallback" style="color:red;">素</span></span></span></span></span></h2>
<p>Go语言中并没有删除切片元素的专用方法，可以使用切片本身的特性来删除元素</p>
<pre><code class="language-/usr/bin/env">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之数组]]></title>
        <id>https://jiajiaba.github.io/post/shuzu</id>
        <link href="https://jiajiaba.github.io/post/shuzu">
        </link>
        <updated>2019-09-02T07:03:10.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言数组的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言数组的基本使用</p>
<!-- more -->
<h2 id="colorredarray数组定义"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span></span></span></span></span></strong></h2>
<p>数组是同一种数据类型元素的集合。<br>
数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>
数组基本语法：<br>
<code>var 数组变量名 [元素数量]类型</code></p>
<pre><code class="language-/usr/bin/env">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mo>:</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">。</mi><mo>[</mo><mn>5</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">和</mi><mo>[</mo><mn>10</mn><mo>]</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{注意:数组的长度必须是常量，一旦定义，长度不能改变。[5]int和[10]int是不同类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">注</span><span class="mord cjk_fallback" style="color:red;">意</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">必</span><span class="mord cjk_fallback" style="color:red;">须</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">量</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">一</span><span class="mord cjk_fallback" style="color:red;">旦</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">义</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">长</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">能</span><span class="mord cjk_fallback" style="color:red;">改</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">。</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">5</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mopen" style="color:red;">[</span><span class="mord" style="color:red;">1</span><span class="mord" style="color:red;">0</span><span class="mclose" style="color:red;">]</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">n</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></p>
<h2 id="colorredarray数组初始化"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">初</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">化</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)初始化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">初</span><span class="mord cjk_fallback" style="color:red;">始</span><span class="mord cjk_fallback" style="color:red;">化</span></span></span></span></span></h2>
<ul>
<li>初始化数组时可以使用初始化列表来设置数组元素的值。</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>短声明</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	x := [3]int{1, 2, 3}
	fmt.Println(x)
}
</code></pre>
<ul>
<li>让编译器根据初始值的个数自行推断数组的长度</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var testArray [3]int                          //数组会初始化为int类型的零值
	var numArray = [...]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                        //[0 0 0]
	fmt.Println(numArray)                         //[1 2 0]
	fmt.Println(cityArray)                        //[北京 上海 深圳]
}
</code></pre>
<ul>
<li>使用指定索引值的方式来初始化数组</li>
</ul>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{1: &quot;北京&quot;, 3: &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	fmt.Println(cityArray)                              //[ 北京  上海 深圳]
	fmt.Printf(&quot;type is %T&quot;, cityArray)                 //type is [5]string
}
</code></pre>
<h2 id="colorredarray数组遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo>(</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mo>)</mo><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{Array(数组)遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定索引值的方式来初始化数组
	//for遍历
	for i := 0; i &lt; len(cityArray); i++ {
		fmt.Println(cityArray[i])
	}
	//for range遍历
	for i, data := range cityArray {
		fmt.Println(i, data)
	}
}
</code></pre>
<h2 id="colorred多维数组"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">多</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{多维数组}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">多</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span></span></span></span></span></h2>
<p>以二维数组为例</p>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[1][1]) //支持索引取值:深圳
}
</code></pre>
<h2 id="colorred二维数组的遍历"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">维</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{二维数组的遍历}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">二</span><span class="mord cjk_fallback" style="color:red;">维</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">遍</span><span class="mord cjk_fallback" style="color:red;">历</span></span></span></span></span></h2>
<pre><code class="language-/usr/bin/env">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>
<p>输出：</p>
<pre><code>北京	上海	
广州	深圳	
成都	重庆
</code></pre>
<p>注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：</p>
<pre><code class="language-/usr/bin/env">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>
<h2 id="colorred数组是值类型"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{数组是值类型}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">组</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">值</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span></span></span></span></span></h2>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<pre><code class="language-/usr/bin/env">func main() {
	var x = [3]int{1, 2, 3}
	fmt.Println(x)
	f1(x)
	fmt.Println(x)
}

func f1(a [3]int) {
	a[0] = 100      //改变第一个值
}
</code></pre>
<p>输出：</p>
<pre><code>[1 2 3]
[1 2 3]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之流程控制]]></title>
        <id>https://jiajiaba.github.io/post/liuchengkongzhi</id>
        <link href="https://jiajiaba.github.io/post/liuchengkongzhi">
        </link>
        <updated>2019-09-02T03:07:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中最常用的流程控制有if和for<br>
switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
 <!-- more -->
<h3 id="colorredifelse分支结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>(</mo><mi mathvariant="normal">分</mi><mi mathvariant="normal">支</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{if..else..(分支结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord mathdefault" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">支</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>if基本使用格式：</p>
<pre><code class="language-Go">if 表达式1 {
    分支1
} else if 表达式2 {
    分支2
} else{
    分支3
}
</code></pre>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	a:=10
	if a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>注意：Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，否则编译错误。</p>
<pre><code class="language-!/usr/bin/env">package main
import &quot;fmt&quot;
func main() {
	if a := 10; a == 20 {
		fmt.Println(&quot;a == 10&quot;)
	} else {
		fmt.Println(&quot;a != 10&quot;)
	}
}
</code></pre>
<p>另外，if语句还支持初始化语句，初始化条件和判断条件以分号分隔。但是需要注意的是，例子中a这个变量只在if语句块里面生效。</p>
<h3 id="colorredfor循环结构"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi mathvariant="normal">循</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">构</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{for(循环结构)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">r</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">循</span><span class="mord cjk_fallback" style="color:red;">环</span><span class="mord cjk_fallback" style="color:red;">结</span><span class="mord cjk_fallback" style="color:red;">构</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<p>for基本使用格式</p>
<pre><code>for 初始语句;条件表达式;结束语句{
			循环体语句
}
</code></pre>
<pre><code class="language-/usr/bin/env">func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<h3 id="其他特殊写法">其他特殊写法</h3>
<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for ; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>
<p>for循环的初始语句和结束语句都可以省略，例如：</p>
<pre><code class="language-/usr/bin/env">func main() {
	i := 0
	for i &lt; 10 {
		fmt.Println(i)
	}
}
</code></pre>
<p>无限循环，例如：</p>
<pre><code class="language-/usr/bin/env">for {
	循环语句体
}
</code></pre>
<p>for range (键值循环)使用，例如:</p>
<pre><code class="language-/usr/bin/env">func main() {
	str := &quot;abc&quot;
	for i, data := range str {
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, data)
	}

	for i := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}

	for i, _ := range str { //第二个返回值默认丢弃，返回元素的位置（下标）
		fmt.Printf(&quot;str[%d] = %c\n&quot;, i, str[i])
	}
}
</code></pre>
<h3 id="colorredswitchcase"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{switch..case..}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="margin-right:0.02691em;color:red;">w</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">h</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span><span class="mord mathdefault" style="color:red;">c</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord mathdefault" style="color:red;">s</span><span class="mord mathdefault" style="color:red;">e</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">.</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	a := 3
	switch a {
	case 1:
		fmt.Println(&quot;First&quot;)
	case 2:
		fmt.Println(&quot;Second&quot;)
	default:
		fmt.Println(&quot;xxx&quot;)
	}
}
</code></pre>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>
<pre><code class="language-/usr/bin/env">func main() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println(&quot;奇数&quot;)
	case 2, 4, 6, 8:
		fmt.Println(&quot;偶数&quot;)
	default:
		fmt.Println(n)
	}
}
</code></pre>
<p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的.</p>
<pre><code class="language-/usr/bin/env">func main() {
	s := &quot;a&quot;
	switch {
	case s == &quot;a&quot;:
		fmt.Println(&quot;a&quot;)
		fallthrough
	case s == &quot;b&quot;:
		fmt.Println(&quot;b&quot;)
	case s == &quot;c&quot;:
		fmt.Println(&quot;c&quot;)
	default:
		fmt.Println(&quot;...&quot;)
	}
}
</code></pre>
<h3 id="colorredgoto跳转到指定标签"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>g</mi><mi>o</mi><mi>t</mi><mi>o</mi><mo>(</mo><mi mathvariant="normal">跳</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">签</mi><mo>)</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{goto(跳转到指定标签)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">o</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">跳</span><span class="mord cjk_fallback" style="color:red;">转</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">指</span><span class="mord cjk_fallback" style="color:red;">定</span><span class="mord cjk_fallback" style="color:red;">标</span><span class="mord cjk_fallback" style="color:red;">签</span><span class="mclose" style="color:red;">)</span></span></span></span></span></h3>
<pre><code class="language-/usr/bin/env">func main() {
	fmt.Println(&quot;111&quot;)

	goto End //goto 是关键字。End是用户起的名字，叫做标签

	fmt.Println(&quot;222&quot;)

End:
	fmt.Println(&quot;333&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础之iota]]></title>
        <id>https://jiajiaba.github.io/post/iota</id>
        <link href="https://jiajiaba.github.io/post/iota">
        </link>
        <updated>2019-09-02T01:10:47.000Z</updated>
        <summary type="html"><![CDATA[<p>Go语言中iota的基本使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Go语言中iota的基本使用</p>
<!-- more -->
<h3 id="colorrediota"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{iota}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span></span></span></span></span></h3>
<p>iota是go语言的常量计数器，只能在常量的表达式中使用<br>
iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次</p>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	n3        //2
	n4        //3
)
</code></pre>
<h3 id="colorred几个常见的iota示例"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">几</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">见</mi><mi mathvariant="normal">的</mi><mi>i</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">例</mi><mo>:</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{几个常见的iota示例:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">几</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">常</span><span class="mord cjk_fallback" style="color:red;">见</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord mathdefault" style="color:red;">i</span><span class="mord mathdefault" style="color:red;">o</span><span class="mord mathdefault" style="color:red;">t</span><span class="mord mathdefault" style="color:red;">a</span><span class="mord cjk_fallback" style="color:red;">示</span><span class="mord cjk_fallback" style="color:red;">例</span><span class="mspace" style="color:red;margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:red;">:</span></span></span></span></span></h3>
<ul>
<li>使用_跳过某些值</li>
</ul>
<pre><code class="language-/usr/bin/env">const (
	n1 = iota //0
	n2        //1
	_
	n4 //3
)
</code></pre>
<ul>
<li>iota声明过程中间插队</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	n1 = iota //0
	n2 = 100  //100
	n3 = iota //2
	n4        //3
)
const n5 = iota //0
</code></pre>
<ul>
<li>多个iota定义在一行</li>
</ul>
<pre><code class="language-!/usr/bin/env">const (
	a, b = iota + 1, iota + 2 //1,2
	c, d                      //2,3
	e, f                      //3,4
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker常用命令]]></title>
        <id>https://jiajiaba.github.io/post/docker-chang-yong-ming-ling</id>
        <link href="https://jiajiaba.github.io/post/docker-chang-yong-ming-ling">
        </link>
        <updated>2019-08-27T01:24:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Docker的一些常用命令。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Docker的一些常用命令。</p>
 <!-- more -->
<p><strong>帮助命令：</strong></p>
<ol>
<li>docker version：显示 Docker 版本信息。</li>
<li>docker info：显示 Docker 系统信息，包括镜像和容器数。</li>
<li>docker --help 帮助命令</li>
</ol>
<p><strong>镜像命令</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>-a：列出本地所有镜像（含中间映像层）</li>
<li>-q：只显示镜像ID</li>
<li>--digests：显示镜像的摘要信息</li>
<li>--no-trunc：显示完整的镜像信息</li>
</ul>
</li>
<li>docker search  从Docker Hub查找镜像
<ul>
<li>-s：列出收藏数不小于指定的镜像</li>
<li>--no-trunc：显示完整的镜像信息</li>
<li>--automated：只列出automated build(自动构建)类型的镜像，也就是非官方的。</li>
</ul>
</li>
<li>docker pull  从Docker Hub下载镜像</li>
<li>docker rmi   删除镜像
<ul>
<li>删除单个：docker rmi -f 镜像ID</li>
<li>删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG</li>
<li>删除全部：docker rmi -f $(docker images -qa)</li>
</ul>
</li>
</ol>
<p><strong>容器命令(有镜像才能创建容器，这是根本前提)</strong></p>
<ol>
<li>docker images  列出本地主机上的镜像
<ul>
<li>--name = &quot;容器新名字&quot;，为容器指定一个名称</li>
<li>-d： 后台运行容器，并返回容器ID，即启动守护式容器</li>
<li>-i：以交互模式运行容器，通常与-t同时使用</li>
<li>-t为容器重新分配一个伪输入终端，通常与-i同时使用</li>
<li>-P：随机端口映射</li>
<li>-p：指定端口映射</li>
</ul>
</li>
<li>docker ps  列出当前正在运行的全部命令
<ul>
<li>-a：列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li>-q：静默模式，只显示容器编号</li>
<li>--no-trunc：不截断输出</li>
</ul>
</li>
<li>退出容器
<ul>
<li>exit：容器停止并且退出</li>
<li>ctrl+P+Q：容器不停止退出</li>
</ul>
</li>
<li>启动容器
<ul>
<li>docker start 容器ID或者容器名</li>
</ul>
</li>
<li>重启容器
<ul>
<li>docker restart 容器ID或者容器名</li>
</ul>
</li>
<li>停止容器
<ul>
<li>docker stop 容器ID或者容器名</li>
</ul>
</li>
<li>强制停止容器
<ul>
<li>docker kill 容器ID或者容器名</li>
</ul>
</li>
<li>删除已经停止的容器
<ul>
<li>docker rm 容器ID</li>
<li>一次性删除多个容器：docker rm -f $(docker ps -qa)</li>
</ul>
</li>
<li>启动守护式进程(即后台运行)
<ul>
<li>docker -d 容器名</li>
</ul>
</li>
<li>查看容器日志：docker logs -f --tail 容器ID
<ul>
<li>-t：是加入的时间戳</li>
<li>-f：跟随最新的日志打印</li>
<li>--tail 数字。显示最后多少条</li>
</ul>
</li>
<li>查看容器内运行的进程
<ul>
<li>docker top 容器ID</li>
</ul>
</li>
<li>查看容器内部细节
<ul>
<li>docker inspect 容器ID</li>
</ul>
</li>
<li>进入正在运行的容器，并以命令行交互
<ul>
<li>docker exec -it 容器ID /bin/bash</li>
<li>重新进入：docker attach 容器ID</li>
<li>两者区别：<br>
attach：直接进入容器启动命令的终端，不会启动新的进程。<br>
exec：是在容器中打开新的终端，并且可以启动新的进程，举例：docker exec - it 容器ID ls -l</li>
</ul>
</li>
<li>从容器内拷贝文件到主机上
<ul>
<li>docker cp 容器ID：容器内路径  目的主机路径</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>